<!DOCTYPE html><html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>第一期讲义-二分法 - 未命名文档</title>
    
<link rel="stylesheet" type="text/css" href="asset/plugins/theme-default/829.index.css"></head>
<body>
<div id="root"><div><div class="Loading__loading___1m_fZ"><div class="Loading__bar___21yOt" style="background: rgb(33, 186, 69); width: 0%; display: none;"><div class="Loading__peg___3Y_28"></div></div></div><div class="Loading__spinner___11Pm4"><div class="Loading__icon___3OOyu" style="display: none; border-color: #21ba45;"></div></div></div><div class="body--4cb30f26 with-sidebar--64a35dd2"><div class="sidebar--92cdcd4d"><div class="header--fbbaa9f2"><a class="title--8b08af4e" href="."><img src="logo.png" width="30" height="30">未命名文档</a><div class="search--783540ff"><input type="search" placeholder="请输入搜索关键词……" value=""></div></div><div class="body--4cb30f26"><div class="summary--54538abb"><ul><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="1.html">Introduction</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="12" width="12" xmlns="http://www.w3.org/2000/svg"><path d="M12.14 8.753l-5.482 4.796c-.646.566-1.658.106-1.658-.753V3.204a1 1 0 011.659-.753l5.48 4.796a1 1 0 010 1.506z"></path></svg></span><a class="text--59d9f9de" href="2.html">第一章 - 算法专题</a></div><ul><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="3.html">数据结构</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="4.html">基础算法</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="5.html">二叉树的遍历</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="6.html">动态规划</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="7.html">哈夫曼编码和游程编码</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="8.html">布隆过滤器</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="9.html">字符串问题</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="10.html">前缀树专题</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="11.html">《贪婪策略》专题</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="12.html">《深度优先遍历》专题</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="13.html">滑动窗口（思路 + 模板）</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="14.html">位运算</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="15.html">设计题</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="16.html">小岛问题</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="17.html">最大公约数</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="18.html">并查集</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="19.html">前缀和</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="20.html">平衡二叉树专题</a></div></li></ul></li><li class="open--57a75e6f"><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="12" width="12" xmlns="http://www.w3.org/2000/svg"><path d="M7.247 11.14L2.451 5.658C1.885 5.013 2.345 4 3.204 4h9.592a1 1 0 01.753 1.659l-4.796 5.48a1 1 0 01-1.506 0z"></path></svg></span><a class="text--59d9f9de" href="21.html">第二章 - 91 天学算法</a></div><ul><li class=""><div class="item--9cbf6482 active--c30e4dc0"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="22.html">第一期讲义-二分法</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="23.html">第一期讲义-双指针</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="24.html">第二期</a></div></li></ul></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="12" width="12" xmlns="http://www.w3.org/2000/svg"><path d="M12.14 8.753l-5.482 4.796c-.646.566-1.658.106-1.658-.753V3.204a1 1 0 011.659-.753l5.48 4.796a1 1 0 010 1.506z"></path></svg></span><a class="text--59d9f9de" href="25.html">第三章 - 精选题解</a></div><ul><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="26.html">《日程安排》专题</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="27.html">《构造二叉树》专题</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="28.html">字典序列删除</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="29.html">百度的算法面试题 * 祖玛游戏</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="30.html">西法的刷题秘籍】一次搞定前缀和</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="31.html">字节跳动的算法面试题是什么难度？</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="32.html">字节跳动的算法面试题是什么难度？（第二弹）</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="33.html">《我是你的妈妈呀》 * 第一期</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="34.html">一文带你看懂二叉树的序列化</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="35.html">穿上衣服我就不认识你了？来聊聊最长上升子序列</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="36.html">你的衣服我扒了 * 《最长公共子序列》</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="37.html">一文看懂《最大子序列和问题》</a></div></li></ul></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="12" width="12" xmlns="http://www.w3.org/2000/svg"><path d="M12.14 8.753l-5.482 4.796c-.646.566-1.658.106-1.658-.753V3.204a1 1 0 011.659-.753l5.48 4.796a1 1 0 010 1.506z"></path></svg></span><a class="text--59d9f9de" href="38.html">第四章 - 高频考题（简单）</a></div><ul><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="39.html">面试题 17.12. BiNode</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="40.html">0001. 两数之和</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="41.html">0020. 有效的括号</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="42.html">0021. 合并两个有序链表</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="43.html">0026. 删除排序数组中的重复项</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="44.html">0053. 最大子序和</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="45.html">0088. 合并两个有序数组</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="46.html">0101. 对称二叉树</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="47.html">0104. 二叉树的最大深度</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="48.html">0108. 将有序数组转换为二叉搜索树</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="49.html">0121. 买卖股票的最佳时机</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="50.html">0122. 买卖股票的最佳时机 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="51.html">0125. 验证回文串</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="52.html">0136. 只出现一次的数字</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="53.html">0155. 最小栈</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="54.html">0167. 两数之和 II * 输入有序数组</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="55.html">0169. 多数元素</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="56.html">0172. 阶乘后的零</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="57.html">0190. 颠倒二进制位</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="58.html">0191. 位1的个数</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="59.html">0198. 打家劫舍</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="60.html">0203. 移除链表元素</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="61.html">0206. 反转链表</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="62.html">0219. 存在重复元素 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="63.html">0226. 翻转二叉树</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="64.html">0232. 用栈实现队列</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="65.html">0263. 丑数</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="66.html">0283. 移动零</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="67.html">0342. 4的幂</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="68.html">0349. 两个数组的交集</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="69.html">0371. 两整数之和</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="70.html">0437. 路径总和 III</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="71.html">0455. 分发饼干</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="72.html">0575. 分糖果</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="73.html">0874. 模拟行走机器人</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="74.html">1260. 二维网格迁移</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="75.html">1332. 删除回文子序列</a></div></li></ul></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="12" width="12" xmlns="http://www.w3.org/2000/svg"><path d="M12.14 8.753l-5.482 4.796c-.646.566-1.658.106-1.658-.753V3.204a1 1 0 011.659-.753l5.48 4.796a1 1 0 010 1.506z"></path></svg></span><a class="text--59d9f9de" href="76.html">第五章 - 高频考题（中等）</a></div><ul><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="77.html">0002. 两数相加</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="78.html">0003. 无重复字符的最长子串</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="79.html">0005. 最长回文子串</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="80.html">0011. 盛最多水的容器</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="81.html">0015. 三数之和</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="82.html">0017. 电话号码的字母组合</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="83.html">0019. 删除链表的倒数第N个节点</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="84.html">0022. 括号生成</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="85.html">0024. 两两交换链表中的节点</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="86.html">0029. 两数相除</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="87.html">0031. 下一个排列</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="88.html">0033. 搜索旋转排序数组</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="89.html">0039. 组合总和</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="90.html">0040. 组合总和 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="91.html">0046. 全排列</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="92.html">0047. 全排列 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="93.html">0048. 旋转图像</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="94.html">0049. 字母异位词分组</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="95.html">0050. Pow(x, n)</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="96.html">0055. 跳跃游戏</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="97.html">0056. 合并区间</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="98.html">0060. 第k个排列</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="99.html">0062. 不同路径</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="100.html">0073. 矩阵置零</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="101.html">0075. 颜色分类</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="102.html">0078. 子集</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="103.html">0079. 单词搜索</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="104.html">0080. 删除排序数组中的重复项 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="105.html">0086. 分隔链表</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="106.html">0090. 子集 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="107.html">0091. 解码方法</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="108.html">0092. 反转链表 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="109.html">0094. 二叉树的中序遍历</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="110.html">0095. 不同的二叉搜索树 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="111.html">0096. 不同的二叉搜索树</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="112.html">0098. 验证二叉搜索树</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="113.html">0102. 二叉树的层序遍历</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="114.html">0103. 二叉树的锯齿形层次遍历</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="115.html">105. 从前序与中序遍历序列构造二叉树</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="116.html">0113. 路径总和 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="117.html">0129. 求根到叶子节点数字之和</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="118.html">0130. 被围绕的区域</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="119.html">0131. 分割回文串</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="120.html">0139. 单词拆分</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="121.html">0144. 二叉树的前序遍历</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="122.html">0150. 逆波兰表达式求值</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="123.html">0152. 乘积最大子数组</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="124.html">0199. 二叉树的右视图</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="125.html">0200. 岛屿数量</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="126.html">0201. 数字范围按位与</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="127.html">0208. 实现 Trie (前缀树)</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="128.html">0209. 长度最小的子数组</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="129.html">0211. 添加与搜索单词 * 数据结构设计</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="130.html">0215. 数组中的第K个最大元素</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="131.html">0221. 最大正方形</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="132.html">0229. 求众数 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="133.html">0230. 二叉搜索树中第K小的元素</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="134.html">0236. 二叉树的最近公共祖先</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="135.html">0238. 除自身以外数组的乘积</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="136.html">0240. 搜索二维矩阵 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="137.html">0279. 完全平方数</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="138.html">0309. 最佳买卖股票时机含冷冻期</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="139.html">0322. 零钱兑换</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="140.html">0328. 奇偶链表</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="141.html">0334. 递增的三元子序列</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="142.html">0337. 打家劫舍 III</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="143.html">0343. 整数拆分</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="144.html">0365. 水壶问题</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="145.html">0378. 有序矩阵中第K小的元素</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="146.html">0380. 常数时间插入、删除和获取随机元素</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="147.html">0416. 分割等和子集</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="148.html">0445. 两数相加 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="149.html">0454. 四数相加 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="150.html">0494. 目标和</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="151.html">0516. 最长回文子序列</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="152.html">0518. 零钱兑换 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="153.html">0547. 朋友圈</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="154.html">0560. 和为K的子数组</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="155.html">0609. 在系统中查找重复文件</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="156.html">0611. 有效三角形的个数</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="157.html">0718. 最长重复子数组</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="158.html">0754. 到达终点数字</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="159.html">0785. 判断二分图</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="160.html">0820. 单词的压缩编码</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="161.html">0875. 爱吃香蕉的珂珂</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="162.html">0877. 石子游戏</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="163.html">0886. 可能的二分法</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="164.html">0900. RLE 迭代器</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="165.html">0912. 排序数组</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="166.html">0935. 骑士拨号器</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="167.html">1011. 在 D 天内送达包裹的能力</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="168.html">1014. 最佳观光组合</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="169.html">1015. 可被 K 整除的最小整数</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="170.html">1019. 链表中的下一个更大节点</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="171.html">1020. 飞地的数量</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="172.html">1023. 驼峰式匹配</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="173.html">1031. 两个非重叠子数组的最大和</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="174.html">1104. 二叉树寻路</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="175.html">1131.绝对值表达式的最大值</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="176.html">1186. 删除一次得到子数组最大和</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="177.html">1218. 最长定差子序列</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="178.html">1227. 飞机座位分配概率</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="179.html">1261. 在受污染的二叉树中查找元素</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="180.html">1262. 可被三整除的最大和</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="181.html">1297. 子串的最大出现次数</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="182.html">1310. 子数组异或查询</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="183.html">1334. 阈值距离内邻居最少的城市</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="184.html">1371.每个元音包含偶数次的最长子字符串</a></div></li></ul></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="12" width="12" xmlns="http://www.w3.org/2000/svg"><path d="M12.14 8.753l-5.482 4.796c-.646.566-1.658.106-1.658-.753V3.204a1 1 0 011.659-.753l5.48 4.796a1 1 0 010 1.506z"></path></svg></span><a class="text--59d9f9de" href="185.html">第六章 - 高频考题（困难）</a></div><ul><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="186.html">0004. 寻找两个正序数组的中位数</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="187.html">0023. 合并K个升序链表</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="188.html">0025. K 个一组翻转链表</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="189.html">0030. 串联所有单词的子串</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="190.html">0032. 最长有效括号</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="191.html">0042. 接雨水</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="192.html">0052. N皇后 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="193.html">0084. 柱状图中最大的矩形</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="194.html">0085. 最大矩形</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="195.html">0124. 二叉树中的最大路径和</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="196.html">0128. 最长连续序列</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="197.html">0145. 二叉树的后序遍历</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="198.html">0212. 单词搜索 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="199.html">0239. 滑动窗口最大值</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="200.html">0295. 数据流的中位数</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="201.html">0301. 删除无效的括号</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="202.html">0312. 戳气球</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="203.html">0335. 路径交叉</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="204.html">0460. LFU缓存</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="205.html">0472. 连接词</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="206.html">0488. 祖玛游戏</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="207.html">0493. 翻转对</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="208.html">0887. 鸡蛋掉落</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="209.html">0895. 最大频率栈</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="210.html">1032. 字符流</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="211.html">1168. 水资源分配优化</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="212.html">1449. 数位成本和为目标值的最大数字</a></div></li></ul></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="213.html">后序</a></div></li></ul></div></div><div class="copyright--2aa57f2d">本文档使用 <a href="https://x.topthink.com" target="_blank">顶想云</a> 构建</div></div><div class="main--6aaec551"><div class="toolbar--af3e5b9e"><h1>第一期讲义-二分法</h1></div><div class="markdown-body"><h1>第一期讲义-二分法</h1><h1>二分查找</h1><p>二分查找又称<code>折半搜索算法</code>。 狭义地来讲，二分查找是一种在有序数组查找某一特定元素的搜索算法。这同时也是大多数人所知道的一种说法。实际上， 广义的二分查找是将问题的规模缩小到原有的一半。类似的，三分法就是将问题规模缩小为原来的 1/3。</p><p>本文给大家带来的内容则是<code>狭义地二分查找</code>，如果想了解其他广义上的二分查找可以查看我之前写的一篇博文 <a href="https://lucifer.ren/blog/2019/12/11/laoshushidu/" target="_blank">从老鼠试毒问题来看二分法</a></p><blockquote><p>尽管二分查找的基本思想相对简单，但细节可以令人难以招架 ... — 高德纳</p></blockquote><p>当乔恩·本特利将二分搜索问题布置给专业编程课的学生时，百分之 90 的学生在花费数小时后还是无法给出正确的解答，主要因为这些错误程序在面对边界值的时候无法运行，或返回错误结果。1988 年开展的一项研究显示，20 本教科书里只有 5 本正确实现了二分搜索。不仅如此，本特利自己 1986 年出版的《编程珠玑》一书中的二分搜索算法存在整数溢出的问题，二十多年来无人发现。Java 语言的库所实现的二分搜索算法中同样的溢出问题存在了九年多才被修复。</p><p>可见二分查找并不简单， 本文就试图带你走近 ta，明白 ta 的底层逻辑，并提供模板帮助大家写书 bug free 的二分查找代码。</p><p>大家可以看完讲义结合 <a href="https://leetcode-cn.com/leetbook/read/binary-search" target="_blank">LeetCode Book 二分查找练习一下</a></p><h2>问题定义</h2><p>给定一个由数字组成的有序数组 nums，并给你一个数字 target。问 nums 中是否存在 target。如果存在， 则返回其在 nums 中的索引。如果不存在，则返回 - 1。</p><p>这是二分查找中最简单的一种形式。当然二分查找也有很多的变形，这也是二分查找容易出错，难以掌握的原因。</p><p>常见变体有：</p><ul><li>如果存在多个满足条件的元素，返回最左边满足条件的索引。</li><li>如果存在多个满足条件的元素，返回最右边满足条件的索引。</li><li>数组不是整体有序的。 比如先升序再降序，或者先降序再升序。</li><li>将一维数组变成二维数组。</li><li>。。。</li></ul><p>接下来，我们逐个进行查看。</p><h2>前提</h2><ul><li>数组是有序的（如果无序，我们也可以考虑排序，不过要注意排序的复杂度）</li></ul><h2>术语</h2><p>二分查找中使用的术语：</p><ul><li>target —— 要查找的值</li><li>index —— 当前位置</li><li>l 和 r —— 左右指针</li><li>mid —— 左右指针的中点，用来确定我们应该向左查找还是向右查找的索引</li></ul><h2>常见题型</h2><h3>查找一个数</h3><p>算法描述：</p><ul><li>先从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；</li><li>如果目标元素大于中间元素，则在数组大于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。</li><li>如果目标元素小于中间元素，则在数组小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。</li><li>如果在某一步骤数组为空，则代表找不到。</li></ul><p><strong>复杂度分析</strong></p><ul><li>平均时间复杂度： O(logN)O(logN)O(logN)</li><li>最坏时间复杂度： O(logN)O(logN)O(logN)</li><li>最优时间复杂度： O(1)O(1)O(1)</li><li>空间复杂度<ul><li>迭代: O(1)O(1)O(1)</li><li>递归： O(logN)O(logN)O(logN)（无尾调用消除）</li></ul></li></ul><blockquote><p>后面的复杂度也是类似的，不再赘述。</p></blockquote><p>这种搜索算法每一次比较都使搜索范围缩小一半，是典型的二分查找。</p><p>这个是二分查找中最简答的一种类型了，我们先来搞定它。 我们来一个具体的例子， 这样方便大家增加代入感。假设 nums 为 <code>[1,3,4,6,7,8,10,13,14]</code>， target 为 4·。</p><ul><li>刚开始数组中间的元素为 7</li><li>7 &gt; 4 ，由于 7 右边的数字都大于 7 ，因此不可能是答案。我们将范围缩写到了 7 的左侧。</li><li>此时中间元素为 3</li><li>3 &lt; 4，由于 3 左边的数字都小于 3 ，因此不可能是答案。我们将范围缩写到了 3 的右侧。</li><li>此时中间元素为 4，正好是我们要找的，返回其索引 2 即可。</li></ul><p>如何将上面的算法转换为容易理解的可执行代码呢？就算是这样一个简简单单，朴实无华的二分查找， 不同的人写出来的差别也是很大的。 如果没有一个思维框架指导你，那么你在不同的时间可能会写出差异很大的代码。这样的话，你犯错的几率会大大增加。</p><p>这里给大家介绍一个我经常使用的思维框架和代码模板。</p><h4>思维框架</h4><p><strong>首先定义搜索区间为 [left, right]，注意是左右都闭合，之后会用到这个点</strong></p><blockquote><p>你可以定义别的搜索区间形式，不过后面的代码也相应要调整，感兴趣的可以试试别的搜索区间。</p></blockquote><ul><li>由于定义的搜索区间为 [left, right]，因此当 left &lt;= right 的时候，搜索区间都不为空，此时我们都需要继续搜索。 也就是说终止搜索条件应该为 left &lt;= right。</li></ul><blockquote><p>举个例子容易明白一点。 比如对于区间 [4,4]，其包含了一个元素 4，因此搜索区间不为空，需要继续搜索（试想 4 恰好是我们要找的 target，如果不继续搜索， 会错过正确答案）。而当搜索区间为 [left, right) 的时候，同样对于 [4,4]，这个时候搜索区间却是空的，因为这样的一个区间不存在任何数字·。</p></blockquote><ul><li>循环体内，我们不断计算 mid ，并将 nums[mid] 与 目标值比对。<ul><li>如果 nums[mid] 等于目标值， 则提前返回 mid（只需要找到一个满足条件的即可）</li><li>如果 nums[mid] 小于目标值， 说明目标值在 mid 右侧，这个时候搜索区间可缩小为 [mid + 1, right] （mid 以及 mid 左侧的数字被我们排除在外）</li><li>如果 nums[mid] 大于目标值， 说明目标值在 mid 左侧，这个时候搜索区间可缩小为 [left, mid - 1] （mid 以及 mid 右侧的数字被我们排除在外）</li></ul></li><li>循环结束都没有找到，则说明找不到，返回 -1 表示未找到。</li></ul><h4>代码模板</h4><h5>Java</h5><pre><code>&lt;pre class="calibre18"&gt;```
&lt;span class="hljs-function"&gt;&lt;span class="hljs-keyword"&gt;public&lt;/span&gt; &lt;span class="hljs-keyword"&gt;int&lt;/span&gt; &lt;span class="hljs-title"&gt;binarySearch&lt;/span&gt;&lt;span class="hljs-params"&gt;(&lt;span class="hljs-keyword"&gt;int&lt;/span&gt;[] nums, &lt;span class="hljs-keyword"&gt;int&lt;/span&gt; target)&lt;/span&gt; &lt;/span&gt;{
    &lt;span class="hljs-title"&gt;// 左右都闭合的区间 [l, r]&lt;/span&gt;
    &lt;span class="hljs-keyword"&gt;int&lt;/span&gt; left = &lt;span class="hljs-params"&gt;0&lt;/span&gt;;
    &lt;span class="hljs-keyword"&gt;int&lt;/span&gt; right = nums.length - &lt;span class="hljs-params"&gt;1&lt;/span&gt;;

    &lt;span class="hljs-keyword"&gt;while&lt;/span&gt;(left &lt;= right) {
        &lt;span class="hljs-keyword"&gt;int&lt;/span&gt; mid = left + (right - left) / &lt;span class="hljs-params"&gt;2&lt;/span&gt;;
        &lt;span class="hljs-keyword"&gt;if&lt;/span&gt;(nums[mid] == target)
            &lt;span class="hljs-keyword"&gt;return&lt;/span&gt; mid;
        &lt;span class="hljs-keyword"&gt;if&lt;/span&gt; (nums[mid] &lt; target)
                  &lt;span class="hljs-title"&gt;// 搜索区间变为 [mid+1, right]&lt;/span&gt;
            left = mid + &lt;span class="hljs-params"&gt;1&lt;/span&gt;;
        &lt;span class="hljs-keyword"&gt;if&lt;/span&gt; (nums[mid] &gt; target)
            &lt;span class="hljs-title"&gt;// 搜索区间变为 [left, mid - 1]&lt;/span&gt;
            right = mid - &lt;span class="hljs-params"&gt;1&lt;/span&gt;;
    }
    &lt;span class="hljs-keyword"&gt;return&lt;/span&gt; -&lt;span class="hljs-params"&gt;1&lt;/span&gt;;
}

</code></pre><pre><code>
##### Python

</code></pre></div><div class="navigation--93943883"><span class="prev--8f062b74">上一篇:<a href="21.html">第二章 - 91 天学算法</a></span><span class="next--1623c556">下一篇:<a href="23.html">第一期讲义-双指针</a></span></div></div></div></div>
<script type="application/payload+json">
{"book":{"id":"219169308@github"},"summary":[{"title":"","articles":[{"title":"Introduction","ref":"1.md","path":"1.html","children":[]},{"title":"第一章 - 算法专题","ref":"2.md","path":"2.html","children":[{"title":"数据结构","ref":"3.md","path":"3.html","children":[]},{"title":"基础算法","ref":"4.md","path":"4.html","children":[]},{"title":"二叉树的遍历","ref":"5.md","path":"5.html","children":[]},{"title":"动态规划","ref":"6.md","path":"6.html","children":[]},{"title":"哈夫曼编码和游程编码","ref":"7.md","path":"7.html","children":[]},{"title":"布隆过滤器","ref":"8.md","path":"8.html","children":[]},{"title":"字符串问题","ref":"9.md","path":"9.html","children":[]},{"title":"前缀树专题","ref":"10.md","path":"10.html","children":[]},{"title":"《贪婪策略》专题","ref":"11.md","path":"11.html","children":[]},{"title":"《深度优先遍历》专题","ref":"12.md","path":"12.html","children":[]},{"title":"滑动窗口（思路 + 模板）","ref":"13.md","path":"13.html","children":[]},{"title":"位运算","ref":"14.md","path":"14.html","children":[]},{"title":"设计题","ref":"15.md","path":"15.html","children":[]},{"title":"小岛问题","ref":"16.md","path":"16.html","children":[]},{"title":"最大公约数","ref":"17.md","path":"17.html","children":[]},{"title":"并查集","ref":"18.md","path":"18.html","children":[]},{"title":"前缀和","ref":"19.md","path":"19.html","children":[]},{"title":"平衡二叉树专题","ref":"20.md","path":"20.html","children":[]}]},{"title":"第二章 - 91 天学算法","ref":"21.md","path":"21.html","children":[{"title":"第一期讲义-二分法","ref":"22.md","path":"22.html","children":[]},{"title":"第一期讲义-双指针","ref":"23.md","path":"23.html","children":[]},{"title":"第二期","ref":"24.md","path":"24.html","children":[]}]},{"title":"第三章 - 精选题解","ref":"25.md","path":"25.html","children":[{"title":"《日程安排》专题","ref":"26.md","path":"26.html","children":[]},{"title":"《构造二叉树》专题","ref":"27.md","path":"27.html","children":[]},{"title":"字典序列删除","ref":"28.md","path":"28.html","children":[]},{"title":"百度的算法面试题 * 祖玛游戏","ref":"29.md","path":"29.html","children":[]},{"title":"西法的刷题秘籍】一次搞定前缀和","ref":"30.md","path":"30.html","children":[]},{"title":"字节跳动的算法面试题是什么难度？","ref":"31.md","path":"31.html","children":[]},{"title":"字节跳动的算法面试题是什么难度？（第二弹）","ref":"32.md","path":"32.html","children":[]},{"title":"《我是你的妈妈呀》 * 第一期","ref":"33.md","path":"33.html","children":[]},{"title":"一文带你看懂二叉树的序列化","ref":"34.md","path":"34.html","children":[]},{"title":"穿上衣服我就不认识你了？来聊聊最长上升子序列","ref":"35.md","path":"35.html","children":[]},{"title":"你的衣服我扒了 * 《最长公共子序列》","ref":"36.md","path":"36.html","children":[]},{"title":"一文看懂《最大子序列和问题》","ref":"37.md","path":"37.html","children":[]}]},{"title":"第四章 - 高频考题（简单）","ref":"38.md","path":"38.html","children":[{"title":"面试题 17.12. BiNode","ref":"39.md","path":"39.html","children":[]},{"title":"0001. 两数之和","ref":"40.md","path":"40.html","children":[]},{"title":"0020. 有效的括号","ref":"41.md","path":"41.html","children":[]},{"title":"0021. 合并两个有序链表","ref":"42.md","path":"42.html","children":[]},{"title":"0026. 删除排序数组中的重复项","ref":"43.md","path":"43.html","children":[]},{"title":"0053. 最大子序和","ref":"44.md","path":"44.html","children":[]},{"title":"0088. 合并两个有序数组","ref":"45.md","path":"45.html","children":[]},{"title":"0101. 对称二叉树","ref":"46.md","path":"46.html","children":[]},{"title":"0104. 二叉树的最大深度","ref":"47.md","path":"47.html","children":[]},{"title":"0108. 将有序数组转换为二叉搜索树","ref":"48.md","path":"48.html","children":[]},{"title":"0121. 买卖股票的最佳时机","ref":"49.md","path":"49.html","children":[]},{"title":"0122. 买卖股票的最佳时机 II","ref":"50.md","path":"50.html","children":[]},{"title":"0125. 验证回文串","ref":"51.md","path":"51.html","children":[]},{"title":"0136. 只出现一次的数字","ref":"52.md","path":"52.html","children":[]},{"title":"0155. 最小栈","ref":"53.md","path":"53.html","children":[]},{"title":"0167. 两数之和 II * 输入有序数组","ref":"54.md","path":"54.html","children":[]},{"title":"0169. 多数元素","ref":"55.md","path":"55.html","children":[]},{"title":"0172. 阶乘后的零","ref":"56.md","path":"56.html","children":[]},{"title":"0190. 颠倒二进制位","ref":"57.md","path":"57.html","children":[]},{"title":"0191. 位1的个数","ref":"58.md","path":"58.html","children":[]},{"title":"0198. 打家劫舍","ref":"59.md","path":"59.html","children":[]},{"title":"0203. 移除链表元素","ref":"60.md","path":"60.html","children":[]},{"title":"0206. 反转链表","ref":"61.md","path":"61.html","children":[]},{"title":"0219. 存在重复元素 II","ref":"62.md","path":"62.html","children":[]},{"title":"0226. 翻转二叉树","ref":"63.md","path":"63.html","children":[]},{"title":"0232. 用栈实现队列","ref":"64.md","path":"64.html","children":[]},{"title":"0263. 丑数","ref":"65.md","path":"65.html","children":[]},{"title":"0283. 移动零","ref":"66.md","path":"66.html","children":[]},{"title":"0342. 4的幂","ref":"67.md","path":"67.html","children":[]},{"title":"0349. 两个数组的交集","ref":"68.md","path":"68.html","children":[]},{"title":"0371. 两整数之和","ref":"69.md","path":"69.html","children":[]},{"title":"0437. 路径总和 III","ref":"70.md","path":"70.html","children":[]},{"title":"0455. 分发饼干","ref":"71.md","path":"71.html","children":[]},{"title":"0575. 分糖果","ref":"72.md","path":"72.html","children":[]},{"title":"0874. 模拟行走机器人","ref":"73.md","path":"73.html","children":[]},{"title":"1260. 二维网格迁移","ref":"74.md","path":"74.html","children":[]},{"title":"1332. 删除回文子序列","ref":"75.md","path":"75.html","children":[]}]},{"title":"第五章 - 高频考题（中等）","ref":"76.md","path":"76.html","children":[{"title":"0002. 两数相加","ref":"77.md","path":"77.html","children":[]},{"title":"0003. 无重复字符的最长子串","ref":"78.md","path":"78.html","children":[]},{"title":"0005. 最长回文子串","ref":"79.md","path":"79.html","children":[]},{"title":"0011. 盛最多水的容器","ref":"80.md","path":"80.html","children":[]},{"title":"0015. 三数之和","ref":"81.md","path":"81.html","children":[]},{"title":"0017. 电话号码的字母组合","ref":"82.md","path":"82.html","children":[]},{"title":"0019. 删除链表的倒数第N个节点","ref":"83.md","path":"83.html","children":[]},{"title":"0022. 括号生成","ref":"84.md","path":"84.html","children":[]},{"title":"0024. 两两交换链表中的节点","ref":"85.md","path":"85.html","children":[]},{"title":"0029. 两数相除","ref":"86.md","path":"86.html","children":[]},{"title":"0031. 下一个排列","ref":"87.md","path":"87.html","children":[]},{"title":"0033. 搜索旋转排序数组","ref":"88.md","path":"88.html","children":[]},{"title":"0039. 组合总和","ref":"89.md","path":"89.html","children":[]},{"title":"0040. 组合总和 II","ref":"90.md","path":"90.html","children":[]},{"title":"0046. 全排列","ref":"91.md","path":"91.html","children":[]},{"title":"0047. 全排列 II","ref":"92.md","path":"92.html","children":[]},{"title":"0048. 旋转图像","ref":"93.md","path":"93.html","children":[]},{"title":"0049. 字母异位词分组","ref":"94.md","path":"94.html","children":[]},{"title":"0050. Pow(x, n)","ref":"95.md","path":"95.html","children":[]},{"title":"0055. 跳跃游戏","ref":"96.md","path":"96.html","children":[]},{"title":"0056. 合并区间","ref":"97.md","path":"97.html","children":[]},{"title":"0060. 第k个排列","ref":"98.md","path":"98.html","children":[]},{"title":"0062. 不同路径","ref":"99.md","path":"99.html","children":[]},{"title":"0073. 矩阵置零","ref":"100.md","path":"100.html","children":[]},{"title":"0075. 颜色分类","ref":"101.md","path":"101.html","children":[]},{"title":"0078. 子集","ref":"102.md","path":"102.html","children":[]},{"title":"0079. 单词搜索","ref":"103.md","path":"103.html","children":[]},{"title":"0080. 删除排序数组中的重复项 II","ref":"104.md","path":"104.html","children":[]},{"title":"0086. 分隔链表","ref":"105.md","path":"105.html","children":[]},{"title":"0090. 子集 II","ref":"106.md","path":"106.html","children":[]},{"title":"0091. 解码方法","ref":"107.md","path":"107.html","children":[]},{"title":"0092. 反转链表 II","ref":"108.md","path":"108.html","children":[]},{"title":"0094. 二叉树的中序遍历","ref":"109.md","path":"109.html","children":[]},{"title":"0095. 不同的二叉搜索树 II","ref":"110.md","path":"110.html","children":[]},{"title":"0096. 不同的二叉搜索树","ref":"111.md","path":"111.html","children":[]},{"title":"0098. 验证二叉搜索树","ref":"112.md","path":"112.html","children":[]},{"title":"0102. 二叉树的层序遍历","ref":"113.md","path":"113.html","children":[]},{"title":"0103. 二叉树的锯齿形层次遍历","ref":"114.md","path":"114.html","children":[]},{"title":"105. 从前序与中序遍历序列构造二叉树","ref":"115.md","path":"115.html","children":[]},{"title":"0113. 路径总和 II","ref":"116.md","path":"116.html","children":[]},{"title":"0129. 求根到叶子节点数字之和","ref":"117.md","path":"117.html","children":[]},{"title":"0130. 被围绕的区域","ref":"118.md","path":"118.html","children":[]},{"title":"0131. 分割回文串","ref":"119.md","path":"119.html","children":[]},{"title":"0139. 单词拆分","ref":"120.md","path":"120.html","children":[]},{"title":"0144. 二叉树的前序遍历","ref":"121.md","path":"121.html","children":[]},{"title":"0150. 逆波兰表达式求值","ref":"122.md","path":"122.html","children":[]},{"title":"0152. 乘积最大子数组","ref":"123.md","path":"123.html","children":[]},{"title":"0199. 二叉树的右视图","ref":"124.md","path":"124.html","children":[]},{"title":"0200. 岛屿数量","ref":"125.md","path":"125.html","children":[]},{"title":"0201. 数字范围按位与","ref":"126.md","path":"126.html","children":[]},{"title":"0208. 实现 Trie (前缀树)","ref":"127.md","path":"127.html","children":[]},{"title":"0209. 长度最小的子数组","ref":"128.md","path":"128.html","children":[]},{"title":"0211. 添加与搜索单词 * 数据结构设计","ref":"129.md","path":"129.html","children":[]},{"title":"0215. 数组中的第K个最大元素","ref":"130.md","path":"130.html","children":[]},{"title":"0221. 最大正方形","ref":"131.md","path":"131.html","children":[]},{"title":"0229. 求众数 II","ref":"132.md","path":"132.html","children":[]},{"title":"0230. 二叉搜索树中第K小的元素","ref":"133.md","path":"133.html","children":[]},{"title":"0236. 二叉树的最近公共祖先","ref":"134.md","path":"134.html","children":[]},{"title":"0238. 除自身以外数组的乘积","ref":"135.md","path":"135.html","children":[]},{"title":"0240. 搜索二维矩阵 II","ref":"136.md","path":"136.html","children":[]},{"title":"0279. 完全平方数","ref":"137.md","path":"137.html","children":[]},{"title":"0309. 最佳买卖股票时机含冷冻期","ref":"138.md","path":"138.html","children":[]},{"title":"0322. 零钱兑换","ref":"139.md","path":"139.html","children":[]},{"title":"0328. 奇偶链表","ref":"140.md","path":"140.html","children":[]},{"title":"0334. 递增的三元子序列","ref":"141.md","path":"141.html","children":[]},{"title":"0337. 打家劫舍 III","ref":"142.md","path":"142.html","children":[]},{"title":"0343. 整数拆分","ref":"143.md","path":"143.html","children":[]},{"title":"0365. 水壶问题","ref":"144.md","path":"144.html","children":[]},{"title":"0378. 有序矩阵中第K小的元素","ref":"145.md","path":"145.html","children":[]},{"title":"0380. 常数时间插入、删除和获取随机元素","ref":"146.md","path":"146.html","children":[]},{"title":"0416. 分割等和子集","ref":"147.md","path":"147.html","children":[]},{"title":"0445. 两数相加 II","ref":"148.md","path":"148.html","children":[]},{"title":"0454. 四数相加 II","ref":"149.md","path":"149.html","children":[]},{"title":"0494. 目标和","ref":"150.md","path":"150.html","children":[]},{"title":"0516. 最长回文子序列","ref":"151.md","path":"151.html","children":[]},{"title":"0518. 零钱兑换 II","ref":"152.md","path":"152.html","children":[]},{"title":"0547. 朋友圈","ref":"153.md","path":"153.html","children":[]},{"title":"0560. 和为K的子数组","ref":"154.md","path":"154.html","children":[]},{"title":"0609. 在系统中查找重复文件","ref":"155.md","path":"155.html","children":[]},{"title":"0611. 有效三角形的个数","ref":"156.md","path":"156.html","children":[]},{"title":"0718. 最长重复子数组","ref":"157.md","path":"157.html","children":[]},{"title":"0754. 到达终点数字","ref":"158.md","path":"158.html","children":[]},{"title":"0785. 判断二分图","ref":"159.md","path":"159.html","children":[]},{"title":"0820. 单词的压缩编码","ref":"160.md","path":"160.html","children":[]},{"title":"0875. 爱吃香蕉的珂珂","ref":"161.md","path":"161.html","children":[]},{"title":"0877. 石子游戏","ref":"162.md","path":"162.html","children":[]},{"title":"0886. 可能的二分法","ref":"163.md","path":"163.html","children":[]},{"title":"0900. RLE 迭代器","ref":"164.md","path":"164.html","children":[]},{"title":"0912. 排序数组","ref":"165.md","path":"165.html","children":[]},{"title":"0935. 骑士拨号器","ref":"166.md","path":"166.html","children":[]},{"title":"1011. 在 D 天内送达包裹的能力","ref":"167.md","path":"167.html","children":[]},{"title":"1014. 最佳观光组合","ref":"168.md","path":"168.html","children":[]},{"title":"1015. 可被 K 整除的最小整数","ref":"169.md","path":"169.html","children":[]},{"title":"1019. 链表中的下一个更大节点","ref":"170.md","path":"170.html","children":[]},{"title":"1020. 飞地的数量","ref":"171.md","path":"171.html","children":[]},{"title":"1023. 驼峰式匹配","ref":"172.md","path":"172.html","children":[]},{"title":"1031. 两个非重叠子数组的最大和","ref":"173.md","path":"173.html","children":[]},{"title":"1104. 二叉树寻路","ref":"174.md","path":"174.html","children":[]},{"title":"1131.绝对值表达式的最大值","ref":"175.md","path":"175.html","children":[]},{"title":"1186. 删除一次得到子数组最大和","ref":"176.md","path":"176.html","children":[]},{"title":"1218. 最长定差子序列","ref":"177.md","path":"177.html","children":[]},{"title":"1227. 飞机座位分配概率","ref":"178.md","path":"178.html","children":[]},{"title":"1261. 在受污染的二叉树中查找元素","ref":"179.md","path":"179.html","children":[]},{"title":"1262. 可被三整除的最大和","ref":"180.md","path":"180.html","children":[]},{"title":"1297. 子串的最大出现次数","ref":"181.md","path":"181.html","children":[]},{"title":"1310. 子数组异或查询","ref":"182.md","path":"182.html","children":[]},{"title":"1334. 阈值距离内邻居最少的城市","ref":"183.md","path":"183.html","children":[]},{"title":"1371.每个元音包含偶数次的最长子字符串","ref":"184.md","path":"184.html","children":[]}]},{"title":"第六章 - 高频考题（困难）","ref":"185.md","path":"185.html","children":[{"title":"0004. 寻找两个正序数组的中位数","ref":"186.md","path":"186.html","children":[]},{"title":"0023. 合并K个升序链表","ref":"187.md","path":"187.html","children":[]},{"title":"0025. K 个一组翻转链表","ref":"188.md","path":"188.html","children":[]},{"title":"0030. 串联所有单词的子串","ref":"189.md","path":"189.html","children":[]},{"title":"0032. 最长有效括号","ref":"190.md","path":"190.html","children":[]},{"title":"0042. 接雨水","ref":"191.md","path":"191.html","children":[]},{"title":"0052. N皇后 II","ref":"192.md","path":"192.html","children":[]},{"title":"0084. 柱状图中最大的矩形","ref":"193.md","path":"193.html","children":[]},{"title":"0085. 最大矩形","ref":"194.md","path":"194.html","children":[]},{"title":"0124. 二叉树中的最大路径和","ref":"195.md","path":"195.html","children":[]},{"title":"0128. 最长连续序列","ref":"196.md","path":"196.html","children":[]},{"title":"0145. 二叉树的后序遍历","ref":"197.md","path":"197.html","children":[]},{"title":"0212. 单词搜索 II","ref":"198.md","path":"198.html","children":[]},{"title":"0239. 滑动窗口最大值","ref":"199.md","path":"199.html","children":[]},{"title":"0295. 数据流的中位数","ref":"200.md","path":"200.html","children":[]},{"title":"0301. 删除无效的括号","ref":"201.md","path":"201.html","children":[]},{"title":"0312. 戳气球","ref":"202.md","path":"202.html","children":[]},{"title":"0335. 路径交叉","ref":"203.md","path":"203.html","children":[]},{"title":"0460. LFU缓存","ref":"204.md","path":"204.html","children":[]},{"title":"0472. 连接词","ref":"205.md","path":"205.html","children":[]},{"title":"0488. 祖玛游戏","ref":"206.md","path":"206.html","children":[]},{"title":"0493. 翻转对","ref":"207.md","path":"207.html","children":[]},{"title":"0887. 鸡蛋掉落","ref":"208.md","path":"208.html","children":[]},{"title":"0895. 最大频率栈","ref":"209.md","path":"209.html","children":[]},{"title":"1032. 字符流","ref":"210.md","path":"210.html","children":[]},{"title":"1168. 水资源分配优化","ref":"211.md","path":"211.html","children":[]},{"title":"1449. 数位成本和为目标值的最大数字","ref":"212.md","path":"212.html","children":[]}]},{"title":"后序","ref":"213.md","path":"213.html","children":[]}]}],"config":{},"file":{"path":"22.html","content":"# 第一期讲义-二分法\n\n# 二分查找\n\n二分查找又称`折半搜索算法`。 狭义地来讲，二分查找是一种在有序数组查找某一特定元素的搜索算法。这同时也是大多数人所知道的一种说法。实际上， 广义的二分查找是将问题的规模缩小到原有的一半。类似的，三分法就是将问题规模缩小为原来的 1/3。\n\n本文给大家带来的内容则是`狭义地二分查找`，如果想了解其他广义上的二分查找可以查看我之前写的一篇博文 [从老鼠试毒问题来看二分法](https://lucifer.ren/blog/2019/12/11/laoshushidu/)\n\n> 尽管二分查找的基本思想相对简单，但细节可以令人难以招架 ... — 高德纳\n\n当乔恩·本特利将二分搜索问题布置给专业编程课的学生时，百分之 90 的学生在花费数小时后还是无法给出正确的解答，主要因为这些错误程序在面对边界值的时候无法运行，或返回错误结果。1988 年开展的一项研究显示，20 本教科书里只有 5 本正确实现了二分搜索。不仅如此，本特利自己 1986 年出版的《编程珠玑》一书中的二分搜索算法存在整数溢出的问题，二十多年来无人发现。Java 语言的库所实现的二分搜索算法中同样的溢出问题存在了九年多才被修复。\n\n可见二分查找并不简单， 本文就试图带你走近 ta，明白 ta 的底层逻辑，并提供模板帮助大家写书 bug free 的二分查找代码。\n\n大家可以看完讲义结合 [LeetCode Book 二分查找练习一下](https://leetcode-cn.com/leetbook/read/binary-search)\n\n## 问题定义\n\n给定一个由数字组成的有序数组 nums，并给你一个数字 target。问 nums 中是否存在 target。如果存在， 则返回其在 nums 中的索引。如果不存在，则返回 - 1。\n\n这是二分查找中最简单的一种形式。当然二分查找也有很多的变形，这也是二分查找容易出错，难以掌握的原因。\n\n常见变体有：\n\n- 如果存在多个满足条件的元素，返回最左边满足条件的索引。\n- 如果存在多个满足条件的元素，返回最右边满足条件的索引。\n- 数组不是整体有序的。 比如先升序再降序，或者先降序再升序。\n- 将一维数组变成二维数组。\n- 。。。\n\n接下来，我们逐个进行查看。\n\n## 前提\n\n- 数组是有序的（如果无序，我们也可以考虑排序，不过要注意排序的复杂度）\n\n## 术语\n\n二分查找中使用的术语：\n\n- target —— 要查找的值\n- index —— 当前位置\n- l 和 r —— 左右指针\n- mid —— 左右指针的中点，用来确定我们应该向左查找还是向右查找的索引\n\n## 常见题型\n\n### 查找一个数\n\n算法描述：\n\n- 先从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；\n- 如果目标元素大于中间元素，则在数组大于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。\n- 如果目标元素小于中间元素，则在数组小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。\n- 如果在某一步骤数组为空，则代表找不到。\n\n**复杂度分析**\n\n- 平均时间复杂度： O(logN)O(logN)O(logN)\n- 最坏时间复杂度： O(logN)O(logN)O(logN)\n- 最优时间复杂度： O(1)O(1)O(1)\n- 空间复杂度\n  - 迭代: O(1)O(1)O(1)\n  - 递归： O(logN)O(logN)O(logN)（无尾调用消除）\n\n> 后面的复杂度也是类似的，不再赘述。\n\n这种搜索算法每一次比较都使搜索范围缩小一半，是典型的二分查找。\n\n这个是二分查找中最简答的一种类型了，我们先来搞定它。 我们来一个具体的例子， 这样方便大家增加代入感。假设 nums 为 `[1,3,4,6,7,8,10,13,14]`， target 为 4·。\n\n- 刚开始数组中间的元素为 7\n- 7 > 4 ，由于 7 右边的数字都大于 7 ，因此不可能是答案。我们将范围缩写到了 7 的左侧。\n- 此时中间元素为 3\n- 3 < 4，由于 3 左边的数字都小于 3 ，因此不可能是答案。我们将范围缩写到了 3 的右侧。\n- 此时中间元素为 4，正好是我们要找的，返回其索引 2 即可。\n\n如何将上面的算法转换为容易理解的可执行代码呢？就算是这样一个简简单单，朴实无华的二分查找， 不同的人写出来的差别也是很大的。 如果没有一个思维框架指导你，那么你在不同的时间可能会写出差异很大的代码。这样的话，你犯错的几率会大大增加。\n\n这里给大家介绍一个我经常使用的思维框架和代码模板。\n\n#### 思维框架\n\n **首先定义搜索区间为 \\[left, right\\]，注意是左右都闭合，之后会用到这个点**\n\n> 你可以定义别的搜索区间形式，不过后面的代码也相应要调整，感兴趣的可以试试别的搜索区间。\n\n- 由于定义的搜索区间为 \\[left, right\\]，因此当 left <= right 的时候，搜索区间都不为空，此时我们都需要继续搜索。 也就是说终止搜索条件应该为 left <= right。\n\n> 举个例子容易明白一点。 比如对于区间 \\[4,4\\]，其包含了一个元素 4，因此搜索区间不为空，需要继续搜索（试想 4 恰好是我们要找的 target，如果不继续搜索， 会错过正确答案）。而当搜索区间为 \\[left, right) 的时候，同样对于 \\[4,4\\]，这个时候搜索区间却是空的，因为这样的一个区间不存在任何数字·。\n\n- 循环体内，我们不断计算 mid ，并将 nums\\[mid\\] 与 目标值比对。\n  - 如果 nums\\[mid\\] 等于目标值， 则提前返回 mid（只需要找到一个满足条件的即可）\n  - 如果 nums\\[mid\\] 小于目标值， 说明目标值在 mid 右侧，这个时候搜索区间可缩小为 \\[mid + 1, right\\] （mid 以及 mid 左侧的数字被我们排除在外）\n  - 如果 nums\\[mid\\] 大于目标值， 说明目标值在 mid 左侧，这个时候搜索区间可缩小为 \\[left, mid - 1\\] （mid 以及 mid 右侧的数字被我们排除在外）\n- 循环结束都没有找到，则说明找不到，返回 -1 表示未找到。\n\n#### 代码模板\n\n##### Java\n\n```\n<pre class=\"calibre18\">```\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">binarySearch</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] nums, <span class=\"hljs-keyword\">int</span> target)</span> </span>{\n    <span class=\"hljs-title\">// 左右都闭合的区间 [l, r]</span>\n    <span class=\"hljs-keyword\">int</span> left = <span class=\"hljs-params\">0</span>;\n    <span class=\"hljs-keyword\">int</span> right = nums.length - <span class=\"hljs-params\">1</span>;\n\n    <span class=\"hljs-keyword\">while</span>(left <= right) {\n        <span class=\"hljs-keyword\">int</span> mid = left + (right - left) / <span class=\"hljs-params\">2</span>;\n        <span class=\"hljs-keyword\">if</span>(nums[mid] == target)\n            <span class=\"hljs-keyword\">return</span> mid;\n        <span class=\"hljs-keyword\">if</span> (nums[mid] < target)\n                  <span class=\"hljs-title\">// 搜索区间变为 [mid+1, right]</span>\n            left = mid + <span class=\"hljs-params\">1</span>;\n        <span class=\"hljs-keyword\">if</span> (nums[mid] > target)\n            <span class=\"hljs-title\">// 搜索区间变为 [left, mid - 1]</span>\n            right = mid - <span class=\"hljs-params\">1</span>;\n    }\n    <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-params\">1</span>;\n}\n\n```\n```\n\n##### Python\n\n```\n<pre class=\"calibre18\">```\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">binarySearch</span><span class=\"hljs-params\">(nums, target)</span>:</span>\n    <span class=\"hljs-title\"># 左右都闭合的区间 [l, r]</span>\n    l, r = <span class=\"hljs-params\">0</span>, len(nums) - <span class=\"hljs-params\">1</span>\n    <span class=\"hljs-keyword\">while</span> l <= r:\n        mid = (left + right) >> <span class=\"hljs-params\">1</span>\n        <span class=\"hljs-keyword\">if</span> nums[mid] == target: <span class=\"hljs-keyword\">return</span> mid\n        <span class=\"hljs-title\"># 搜索区间变为 [mid+1, right]</span>\n        <span class=\"hljs-keyword\">if</span> nums[mid] < target: l = mid + <span class=\"hljs-params\">1</span>\n        <span class=\"hljs-title\"># 搜索区间变为 [left, mid - 1]</span>\n        <span class=\"hljs-keyword\">if</span> nums[mid] > target: r = mid - <span class=\"hljs-params\">1</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-params\">-1</span>\n\n```\n```\n\n##### JavaScript\n\n```\n<pre class=\"calibre18\">```\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">binarySearch</span>(<span class=\"hljs-params\">nums, target</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> left = <span class=\"hljs-params\">0</span>;\n  <span class=\"hljs-keyword\">let</span> right = nums.length - <span class=\"hljs-params\">1</span>;\n  <span class=\"hljs-keyword\">while</span> (left <= right) {\n    <span class=\"hljs-keyword\">const</span> mid = <span class=\"hljs-params\">Math</span>.floor(left + (right - left) / <span class=\"hljs-params\">2</span>);\n    <span class=\"hljs-keyword\">if</span> (nums[mid] == target) <span class=\"hljs-keyword\">return</span> mid;\n    <span class=\"hljs-keyword\">if</span> (nums[mid] < target)\n      <span class=\"hljs-title\">// 搜索区间变为 [mid+1, right]</span>\n      left = mid + <span class=\"hljs-params\">1</span>;\n    <span class=\"hljs-keyword\">if</span> (nums[mid] > target)\n      <span class=\"hljs-title\">// 搜索区间变为 [left, mid - 1]</span>\n      right = mid - <span class=\"hljs-params\">1</span>;\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-params\">-1</span>;\n}\n\n```\n```\n\n##### C++\n\n暂时空缺，欢迎 [PR](https://github.com/leetcode-pp/leetcode-cheat/pulls)\n\n```\n<pre class=\"calibre18\">```\n\n\n\n```\n```\n\n### 寻找最左边的满足条件的值\n\n和`查找一个数`类似， 我们仍然套用`查找一个数`的思维框架和代码模板。\n\n#### 思维框架\n\n- 首先定义搜索区间为 \\[left, right\\]，注意是左右都闭合，之后会用到这个点。\n- 终止搜索条件为 left <= right。\n- 循环体内，我们不断计算 mid ，并将 nums\\[mid\\] 与 目标值比对。\n  - 如果 nums\\[mid\\] 等于目标值， 则收缩右边界，我们找到了一个备胎，继续看看左边还有没有了（**注意这里不一样**）\n  - 如果 nums\\[mid\\] 小于目标值， 说明目标值在 mid 右侧，这个时候搜索区间可缩小为 \\[mid + 1, right\\]\n  - 如果 nums\\[mid\\] 大于目标值， 说明目标值在 mid 左侧，这个时候搜索区间可缩小为 \\[left, mid - 1\\]\n- 由于不会提前返回，因此我们需要检查最终的 left，看 nums\\[left\\]是否等于 target。\n  - 如果不等于 target，或者 left 出了右边边界了，说明至死都没有找到一个备胎，则返回 -1.\n  - 否则返回 left 即可，备胎转正。\n\n#### 代码模板\n\n> 实际上 nums\\[mid\\] > target 和 nums\\[mid\\] == target 是可以合并的。我这里为了清晰，就没有合并，大家熟悉之后合并起来即可。\n\n##### Java\n\n```\n<pre class=\"calibre18\">```\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">binarySearchLeft</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] nums, <span class=\"hljs-keyword\">int</span> target)</span> </span>{\n    <span class=\"hljs-title\">// 搜索区间为 [left, right]</span>\n    <span class=\"hljs-keyword\">int</span> left = <span class=\"hljs-params\">0</span>;\n    <span class=\"hljs-keyword\">int</span> right = nums.length - <span class=\"hljs-params\">1</span>;\n    <span class=\"hljs-keyword\">while</span> (left <= right) {\n        <span class=\"hljs-keyword\">int</span> mid = left + (right - left) / <span class=\"hljs-params\">2</span>;\n        <span class=\"hljs-keyword\">if</span> (nums[mid] < target) {\n            <span class=\"hljs-title\">// 搜索区间变为 [mid+1, right]</span>\n            left = mid + <span class=\"hljs-params\">1</span>;\n        }\n        <span class=\"hljs-keyword\">if</span> (nums[mid] > target) {\n            <span class=\"hljs-title\">// 搜索区间变为 [left, mid-1]</span>\n            right = mid - <span class=\"hljs-params\">1</span>;\n        }\n        <span class=\"hljs-keyword\">if</span> (nums[mid] == target) {\n            <span class=\"hljs-title\">// 收缩右边界</span>\n            right = mid - <span class=\"hljs-params\">1</span>;\n        }\n    }\n    <span class=\"hljs-title\">// 检查是否越界</span>\n    <span class=\"hljs-keyword\">if</span> (left >= nums.length || nums[left] != target)\n        <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-params\">1</span>;\n    <span class=\"hljs-keyword\">return</span> left;\n}\n\n```\n```\n\n##### Python\n\n```\n<pre class=\"calibre18\">```\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">binarySearchLeft</span><span class=\"hljs-params\">(nums, target)</span>:</span>\n    <span class=\"hljs-title\"># 左右都闭合的区间 [l, r]</span>\n    l, r = <span class=\"hljs-params\">0</span>, len(nums) - <span class=\"hljs-params\">1</span>\n    <span class=\"hljs-keyword\">while</span> l <= r:\n        mid = (l + r) >> <span class=\"hljs-params\">1</span>\n        <span class=\"hljs-keyword\">if</span> nums[mid] == target:\n            <span class=\"hljs-title\"># 收缩右边界</span>\n            r = mid - <span class=\"hljs-params\">1</span>;\n        <span class=\"hljs-title\"># 搜索区间变为 [mid+1, right]</span>\n        <span class=\"hljs-keyword\">if</span> nums[mid] < target: l = mid + <span class=\"hljs-params\">1</span>\n        <span class=\"hljs-title\"># 搜索区间变为 [left, mid - 1]</span>\n        <span class=\"hljs-keyword\">if</span> nums[mid] > target: r = mid - <span class=\"hljs-params\">1</span>\n    <span class=\"hljs-keyword\">if</span> l >= len(nums) <span class=\"hljs-keyword\">or</span> nums[l] != target: <span class=\"hljs-keyword\">return</span> <span class=\"hljs-params\">-1</span>\n    <span class=\"hljs-keyword\">return</span> l\n\n```\n```\n\n##### JavaScript\n\n```\n<pre class=\"calibre18\">```\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">binarySearchLeft</span>(<span class=\"hljs-params\">nums, target</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> left = <span class=\"hljs-params\">0</span>;\n  <span class=\"hljs-keyword\">let</span> right = nums.length - <span class=\"hljs-params\">1</span>;\n  <span class=\"hljs-keyword\">while</span> (left <= right) {\n    <span class=\"hljs-keyword\">const</span> mid = <span class=\"hljs-params\">Math</span>.floor(left + (right - left) / <span class=\"hljs-params\">2</span>);\n    <span class=\"hljs-keyword\">if</span> (nums[mid] == target)\n      <span class=\"hljs-title\">// 收缩右边界</span>\n      right = mid - <span class=\"hljs-params\">1</span>;\n    <span class=\"hljs-keyword\">if</span> (nums[mid] < target)\n      <span class=\"hljs-title\">// 搜索区间变为 [mid+1, right]</span>\n      left = mid + <span class=\"hljs-params\">1</span>;\n    <span class=\"hljs-keyword\">if</span> (nums[mid] > target)\n      <span class=\"hljs-title\">// 搜索区间变为 [left, mid - 1]</span>\n      right = mid - <span class=\"hljs-params\">1</span>;\n  }\n  <span class=\"hljs-title\">// 检查是否越界</span>\n  <span class=\"hljs-keyword\">if</span> (left >= nums.length || nums[left] != target) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-params\">-1</span>;\n  <span class=\"hljs-keyword\">return</span> left;\n}\n\n```\n```\n\n##### C++\n\n暂时空缺，欢迎 [PR](https://github.com/leetcode-pp/leetcode-cheat/pulls)\n\n```\n<pre class=\"calibre18\">```\n\n\n\n```\n```\n\n### 寻找最右边的满足条件的值\n\n和`查找一个数`类似， 我们仍然套用`查找一个数`的思维框架和代码模板。\n\n> 有没有感受到框架和模板的力量？\n\n#### 思维框架\n\n- 首先定义搜索区间为 \\[left, right\\]，注意是左右都闭合，之后会用到这个点。\n\n> 你可以定义别的搜索区间形式，不过后面的代码也相应要调整，感兴趣的可以试试别的搜索区间。\n\n- 由于我们定义的搜索区间为 \\[left, right\\]，因此当 left <= right 的时候，搜索区间都不为空。 也就是说我们的终止搜索条件为 left <= right。\n\n> 举个例子容易明白一点。 比如对于区间 \\[4,4\\]，其包含了一个元素 4，因此搜索区间不为空。而当搜索区间为 \\[left, right) 的时候，同样对于 \\[4,4\\]，这个时候搜索区间却是空的。\n\n- 循环体内，我们不断计算 mid ，并将 nums\\[mid\\] 与 目标值比对。\n  - 如果 nums\\[mid\\] 等于目标值， 则收缩左边界，我们找到了一个备胎，继续看看右边还有没有了\n  - 如果 nums\\[mid\\] 小于目标值， 说明目标值在 mid 右侧，这个时候搜索区间可缩小为 \\[mid + 1, right\\]\n  - 如果 nums\\[mid\\] 大于目标值， 说明目标值在 mid 左侧，这个时候搜索区间可缩小为 \\[left, mid - 1\\]\n- 由于不会提前返回，因此我们需要检查最终的 right，看 nums\\[right\\]是否等于 target。\n  - 如果不等于 target，或者 right 出了左边边界了，说明至死都没有找到一个备胎，则返回 -1.\n  - 否则返回 right 即可，备胎转正。\n\n#### 代码模板\n\n> 实际上 nums\\[mid\\] < target 和 nums\\[mid\\] == target 是可以合并的。我这里为了清晰，就没有合并，大家熟悉之后合并起来即可。\n\n##### Java\n\n```\n<pre class=\"calibre18\">```\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">binarySearchRight</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] nums, <span class=\"hljs-keyword\">int</span> target)</span> </span>{\n    <span class=\"hljs-title\">// 搜索区间为 [left, right]</span>\n    <span class=\"hljs-keyword\">int</span> left = <span class=\"hljs-params\">0</span>\n    <span class=\"hljs-keyword\">int</span> right = nums.length - <span class=\"hljs-params\">1</span>;\n    <span class=\"hljs-keyword\">while</span> (left <= right) {\n        <span class=\"hljs-keyword\">int</span> mid = left + (right - left) / <span class=\"hljs-params\">2</span>;\n        <span class=\"hljs-keyword\">if</span> (nums[mid] < target) {\n            <span class=\"hljs-title\">// 搜索区间变为 [mid+1, right]</span>\n            left = mid + <span class=\"hljs-params\">1</span>;\n        }\n        <span class=\"hljs-keyword\">if</span> (nums[mid] > target) {\n            <span class=\"hljs-title\">// 搜索区间变为 [left, mid-1]</span>\n            right = mid - <span class=\"hljs-params\">1</span>;\n        }\n        <span class=\"hljs-keyword\">if</span> (nums[mid] == target) {\n            <span class=\"hljs-title\">// 收缩左边界</span>\n            left = mid + <span class=\"hljs-params\">1</span>;\n        }\n    }\n    <span class=\"hljs-title\">// 检查是否越界</span>\n    <span class=\"hljs-keyword\">if</span> (right < <span class=\"hljs-params\">0</span> || nums[right] != target)\n        <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-params\">1</span>;\n    <span class=\"hljs-keyword\">return</span> right;\n}\n\n```\n```\n\n##### Python\n\n```\n<pre class=\"calibre18\">```\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">binarySearchRight</span><span class=\"hljs-params\">(nums, target)</span>:</span>\n    <span class=\"hljs-title\"># 左右都闭合的区间 [l, r]</span>\n    l, r = <span class=\"hljs-params\">0</span>, len(nums) - <span class=\"hljs-params\">1</span>\n    <span class=\"hljs-keyword\">while</span> l <= r:\n        mid = (l + r) >> <span class=\"hljs-params\">1</span>\n        <span class=\"hljs-keyword\">if</span> nums[mid] == target:\n            <span class=\"hljs-title\"># 收缩左边界</span>\n            l = mid + <span class=\"hljs-params\">1</span>;\n        <span class=\"hljs-title\"># 搜索区间变为 [mid+1, right]</span>\n        <span class=\"hljs-keyword\">if</span> nums[mid] < target: l = mid + <span class=\"hljs-params\">1</span>\n        <span class=\"hljs-title\"># 搜索区间变为 [left, mid - 1]</span>\n        <span class=\"hljs-keyword\">if</span> nums[mid] > target: r = mid - <span class=\"hljs-params\">1</span>\n    <span class=\"hljs-keyword\">if</span> r < <span class=\"hljs-params\">0</span> <span class=\"hljs-keyword\">or</span> nums[r] != target: <span class=\"hljs-keyword\">return</span> <span class=\"hljs-params\">-1</span>\n    <span class=\"hljs-keyword\">return</span> r\n\n```\n```\n\n##### JavaScript\n\n```\n<pre class=\"calibre18\">```\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">binarySearchRight</span>(<span class=\"hljs-params\">nums, target</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> left = <span class=\"hljs-params\">0</span>;\n  <span class=\"hljs-keyword\">let</span> right = nums.length - <span class=\"hljs-params\">1</span>;\n  <span class=\"hljs-keyword\">while</span> (left <= right) {\n    <span class=\"hljs-keyword\">const</span> mid = <span class=\"hljs-params\">Math</span>.floor(left + (right - left) / <span class=\"hljs-params\">2</span>);\n    <span class=\"hljs-keyword\">if</span> (nums[mid] == target)\n      <span class=\"hljs-title\">// 收缩左边界</span>\n      left = mid + <span class=\"hljs-params\">1</span>;\n    <span class=\"hljs-keyword\">if</span> (nums[mid] < target)\n      <span class=\"hljs-title\">// 搜索区间变为 [mid+1, right]</span>\n      left = mid + <span class=\"hljs-params\">1</span>;\n    <span class=\"hljs-keyword\">if</span> (nums[mid] > target)\n      <span class=\"hljs-title\">// 搜索区间变为 [left, mid - 1]</span>\n      right = mid - <span class=\"hljs-params\">1</span>;\n  }\n  <span class=\"hljs-title\">// 检查是否越界</span>\n  <span class=\"hljs-keyword\">if</span> (right < <span class=\"hljs-params\">0</span> || nums[right] != target) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-params\">-1</span>;\n  <span class=\"hljs-keyword\">return</span> right;\n}\n\n```\n```\n\n##### C++\n\n暂时空缺，欢迎 [PR](https://github.com/leetcode-pp/leetcode-cheat/pulls)\n\n```\n<pre class=\"calibre18\">```\n\n\n\n```\n```\n\n### 局部有序（先降后升或先升后降）\n\nLeetCode 有原题 [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/) 和 [81. 搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)， 我们直接拿过来讲解好了。\n\n其中 81 题是在 33 题的基础上增加了`包含重复元素`的可能，实际上 33 题的进阶就是 81 题。通过这道题，大家可以感受到”包含重复与否对我们算法的影响“。 我们直接上最复杂的 81 题，这个会了，可以直接 AC 第 33 题。\n\n#### 81. 搜索旋转排序数组 II\n\n##### 题目描述\n\n```\n<pre class=\"calibre18\">```\n假设按照升序排序的数组在预先未知的某个点上进行了旋转。\n\n( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。\n\n编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。\n\n示例 1:\n\n输入: nums = [2,5,6,0,0,1,2], target = 0\n输出: true\n示例 2:\n\n输入: nums = [2,5,6,0,0,1,2], target = 3\n输出: false\n进阶:\n\n这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。\n这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？\n\n```\n```\n\n##### 思路\n\n这是一个我在网上看到的前端头条技术终面的一个算法题。我们先不考虑重复元素。\n\n题目要求时间复杂度为 logn，因此基本就是二分法了。 这道题目不是直接的有序数组，不然就是 easy 了。\n\n首先要知道，我们随便选择一个点，将数组分为前后两部分，其中一部分一定是有序的。\n\n具体步骤：\n\n- 我们可以先找出 mid，然后根据 mid 来判断，mid 是在有序的部分还是无序的部分\n\n假如 mid 小于 start，则 mid 一定在右边有序部分。 假如 mid 大于 start，则 mid 一定在左边有序部分。\n\n> 注意我没有考虑等号，之后我会讲。\n\n- 然后我们继续判断 target 在哪一部分， 我们就可以舍弃另一部分了\n\n我们只需要比较 target 和有序部分的边界关系就行了。 比如 mid 在右侧有序部分，即\\[mid, end\\] 那么我们只需要判断 target >= mid && target <= end 就能知道 target 在右侧有序部分，我们就 可以舍弃左边部分了(start = mid + 1)， 反之亦然。\n\n我们以(\\[6,7,8,1,2,3,4,5\\], 4)为例讲解一下：\n\n![](images/a99dd8dd0a530f555616e5dc3c6ac436962a4743.jpg)\n\n![](images/7bad90580a5fb07b9f80e2792fb33bb52b3a412e.jpg)\n\n接下来，我们考虑重复元素的问题。就会发生 nums\\[mid\\] == nums\\[start\\] 了，比如 30333 。这个时候，可以选择 l 右移一位。有的同学会担心”会不会错失目标元素？“。其实这个担心是多余的，前面我们已经介绍了”搜索区间“。由于搜索区间同时包含 l 和 mid ，因此去除一个 l ，我们还有 mid。假如 3 是我们要找的元素， 这样进行下去绝对不会错过，而是收缩”搜索区间“到一个元素 3 ，我们就可以心安理得地返回 3 了。\n\n##### 代码（Python）\n\n```\n<pre class=\"calibre18\">```\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span>:</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">search</span><span class=\"hljs-params\">(self, nums, target)</span>:</span>\n        l, r = <span class=\"hljs-params\">0</span>, len(nums)<span class=\"hljs-params\">-1</span>\n        <span class=\"hljs-keyword\">while</span> l <= r:\n            mid = l + (r-l)//<span class=\"hljs-params\">2</span>\n            <span class=\"hljs-keyword\">if</span> nums[mid] == target:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">True</span>\n            <span class=\"hljs-keyword\">while</span> l < mid <span class=\"hljs-keyword\">and</span> nums[l] == nums[mid]:  <span class=\"hljs-title\"># tricky part</span>\n                l += <span class=\"hljs-params\">1</span>\n            <span class=\"hljs-title\"># the first half is ordered</span>\n            <span class=\"hljs-keyword\">if</span> nums[l] <= nums[mid]:\n                <span class=\"hljs-title\"># target is in the first half</span>\n                <span class=\"hljs-keyword\">if</span> nums[l] <= target < nums[mid]:\n                    r = mid - <span class=\"hljs-params\">1</span>\n                <span class=\"hljs-keyword\">else</span>:\n                    l = mid + <span class=\"hljs-params\">1</span>\n            <span class=\"hljs-title\"># the second half is ordered</span>\n            <span class=\"hljs-keyword\">else</span>:\n                <span class=\"hljs-title\"># target is in the second half</span>\n                <span class=\"hljs-keyword\">if</span> nums[mid] < target <= nums[r]:\n                    l = mid + <span class=\"hljs-params\">1</span>\n                <span class=\"hljs-keyword\">else</span>:\n                    r = mid - <span class=\"hljs-params\">1</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">False</span>\n\n```\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(logN)O(log N)O(logN)\n- 空间复杂度：O(1)O(1)O(1)\n\n### 二维数组\n\n二维数组的二分查找和一维没有本质区别， 我们通过两个题来进行说明。\n\n#### 74. 搜索二维矩阵\n\n##### 题目地址\n\n<https://leetcode-cn.com/problems/search-a-2d-matrix/>\n\n##### 题目描述\n\n```\n<pre class=\"calibre18\">```\n编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：\n\n每行中的整数从左到右按升序排列。\n每行的第一个整数大于前一行的最后一个整数。\n示例 1:\n\n输入:\nmatrix = [\n  [1,   3,  5,  7],\n  [10, 11, 16, 20],\n  [23, 30, 34, 50]\n]\ntarget = 3\n输出: true\n示例 2:\n\n输入:\nmatrix = [\n  [1,   3,  5,  7],\n  [10, 11, 16, 20],\n  [23, 30, 34, 50]\n]\ntarget = 13\n输出: false\n\n```\n```\n\n##### 思路\n\n简单来说就是将一个一维有序数组切成若干长度相同的段，然后将这些段拼接成一个二维数组。你的任务就是在这个拼接成的二维数组中找到 target。\n\n需要注意的是，数组是不存在重复元素的。\n\n> 如果有重复元素，我们该怎么办？\n\n算法：\n\n- 选择矩阵左下角作为起始元素 Q\n- 如果 Q > target，右方和下方的元素没有必要看了（相对于一维数组的右边元素）\n- 如果 Q < target，左方和上方的元素没有必要看了（相对于一维数组的左边元素）\n- 如果 Q == target ，直接 返回 True\n- 交回了都找不到，返回 False\n\n##### 代码(Python)\n\n```\n<pre class=\"calibre18\">```\n\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span>:</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">searchMatrix</span><span class=\"hljs-params\">(self, matrix: List[List[int]], target: int)</span> -> bool:</span>\n        m = len(matrix)\n        <span class=\"hljs-keyword\">if</span> m == <span class=\"hljs-params\">0</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">False</span>\n        n = len(matrix[<span class=\"hljs-params\">0</span>])\n\n        x = m - <span class=\"hljs-params\">1</span>\n        y = <span class=\"hljs-params\">0</span>\n        <span class=\"hljs-keyword\">while</span> x >= <span class=\"hljs-params\">0</span> <span class=\"hljs-keyword\">and</span> y < n:\n            <span class=\"hljs-keyword\">if</span> matrix[x][y] > target:\n                x -= <span class=\"hljs-params\">1</span>\n            <span class=\"hljs-keyword\">elif</span> matrix[x][y] < target:\n                y += <span class=\"hljs-params\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">True</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">False</span>\n\n```\n```\n\n**复杂度分析**\n\n- 时间复杂度：最坏的情况是只有一行或者只有一列，此时时间复杂度为 O(M∗N)O(M \\* N)O(M∗N)。更多的情况下时间复杂度为 O(M+N)O(M + N)O(M+N)\n- 空间复杂度：O(1)O(1)O(1)\n\n力扣 [240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/) 发生了一点变化，不再是`每行的第一个整数大于前一行的最后一个整数`，而是 `每列的元素从上到下升序排列`。我们仍然可以选择左下进行二分。\n\n### 寻找最值(改进的二分)\n\n上面全部都是找到给定值，这次我们试图寻找最值（最小或者最大）。我们以最小为例，讲解一下这种题如何切入。\n\n##### 153. 寻找旋转排序数组中的最小值\n\n##### 题目地址\n\n<https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/>\n\n##### 题目描述\n\n```\n<pre class=\"calibre18\">```\n假设按照升序排序的数组在预先未知的某个点上进行了旋转。\n\n( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。\n\n请找出其中最小的元素。\n\n你可以假设数组中不存在重复元素。\n\n示例 1:\n\n输入: [3,4,5,1,2]\n输出: 1\n示例 2:\n\n输入: [4,5,6,7,0,1,2]\n输出: 0\n\n```\n```\n\n##### 二分法\n\n###### 思路\n\n和查找指定值得思路一样。我们还是：\n\n- 初始化首尾指针 l 和 r\n- 如果 nums\\[mid\\] 大于 nums\\[r\\]，说明 mid 在左侧有序部分，由于最小的一定在右侧，因此可以收缩左区间，即 l = mid + 1\n- 否则收缩右侧，即 r = mid（不可以 r = mid - 1）\n\n> 这里多判断等号没有意义，因为题目没有让我们找指定值\n\n- 当 l >= r 或者 nums\\[l\\] < nums\\[r\\] 的时候退出循环\n\n> nums\\[l\\] < nums\\[r\\]，说明区间 \\[l, r\\] 已经是整体有序了，因此 nums\\[l\\] 就是我们想要找的\n\n###### 代码（Python）\n\n```\n<pre class=\"calibre18\">```\n\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span>:</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">findMin</span><span class=\"hljs-params\">(self, nums: List[int])</span> -> int:</span>\n        l, r = <span class=\"hljs-params\">0</span>, len(nums) - <span class=\"hljs-params\">1</span>\n\n        <span class=\"hljs-keyword\">while</span> l < r:\n            <span class=\"hljs-title\"># important</span>\n            <span class=\"hljs-keyword\">if</span> nums[l] < nums[r]:\n                <span class=\"hljs-keyword\">return</span> nums[l]\n            mid = (l + r) // <span class=\"hljs-params\">2</span>\n            <span class=\"hljs-title\"># left part</span>\n            <span class=\"hljs-keyword\">if</span> nums[mid] > nums[r]:\n                l = mid + <span class=\"hljs-params\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                <span class=\"hljs-title\"># right part</span>\n                r = mid\n        <span class=\"hljs-title\"># l or r is not important</span>\n        <span class=\"hljs-keyword\">return</span> nums[l]\n\n```\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(logN)O(log N)O(logN)\n- 空间复杂度：O(1)O(1)O(1)\n\n##### 另一种二分法\n\n###### 思路\n\n我们当然也也可以和 nums\\[l\\] 比较，而不是上面的 nums\\[r\\]，我们发现：\n\n- 旋转点左侧元素**都大于**数组第一个元素\n- 旋转点右侧元素**都小于**数组第一个元素\n\n这样就建立了 nums\\[mid\\] 和 nums\\[0\\] 的联系。\n\n具体算法：\n\n1. 找到数组的中间元素 mid。\n2. 如果中间元素 > 数组第一个元素，我们需要在 mid 右边搜索。\n\n![](images/1ca5af2f2c7b692c6d54ee04c67c4334530f7bdc.jpg)\n\n- 如果中间元素 <= 数组第一个元素，我们需要在 mid 左边搜索。\n\n上面的例子中，中间元素 6 比第一个元素 4 大，因此在中间点右侧继续搜索。\n\n1. 当我们找到旋转点时停止搜索，当以下条件满足任意一个即可：\n2. nums\\[mid\\] > nums\\[mid + 1\\]，因此 mid+1 是最小值。\n3. nums\\[mid - 1\\] > nums\\[mid\\]，因此 mid 是最小值。\n\n![](images/dffa9885a8dff84051fe7746e9031ad9efc6c422.jpg)\n\n###### 代码（Python）\n\n```\n<pre class=\"calibre18\">```\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span>:</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">findMin</span><span class=\"hljs-params\">(self, nums)</span>:</span>\n        <span class=\"hljs-title\"># If the list has just one element then return that element.</span>\n        <span class=\"hljs-keyword\">if</span> len(nums) == <span class=\"hljs-params\">1</span>:\n            <span class=\"hljs-keyword\">return</span> nums[<span class=\"hljs-params\">0</span>]\n\n        <span class=\"hljs-title\"># left pointer</span>\n        left = <span class=\"hljs-params\">0</span>\n        <span class=\"hljs-title\"># right pointer</span>\n        right = len(nums) - <span class=\"hljs-params\">1</span>\n\n        <span class=\"hljs-title\"># if the last element is greater than the first element then there is no rotation.</span>\n        <span class=\"hljs-title\"># e.g. 1 < 2 < 3 < 4 < 5 < 7. Already sorted array.</span>\n        <span class=\"hljs-title\"># Hence the smallest element is first element. A[0]</span>\n        <span class=\"hljs-keyword\">if</span> nums[right] > nums[<span class=\"hljs-params\">0</span>]:\n            <span class=\"hljs-keyword\">return</span> nums[<span class=\"hljs-params\">0</span>]\n\n        <span class=\"hljs-title\"># Binary search way</span>\n        <span class=\"hljs-keyword\">while</span> right >= left:\n            <span class=\"hljs-title\"># Find the mid element</span>\n            mid = left + (right - left) / <span class=\"hljs-params\">2</span>\n            <span class=\"hljs-title\"># if the mid element is greater than its next element then mid+1 element is the smallest</span>\n            <span class=\"hljs-title\"># This point would be the point of change. From higher to lower value.</span>\n            <span class=\"hljs-keyword\">if</span> nums[mid] > nums[mid + <span class=\"hljs-params\">1</span>]:\n                <span class=\"hljs-keyword\">return</span> nums[mid + <span class=\"hljs-params\">1</span>]\n            <span class=\"hljs-title\"># if the mid element is lesser than its previous element then mid element is the smallest</span>\n            <span class=\"hljs-keyword\">if</span> nums[mid - <span class=\"hljs-params\">1</span>] > nums[mid]:\n                <span class=\"hljs-keyword\">return</span> nums[mid]\n\n            <span class=\"hljs-title\"># if the mid elements value is greater than the 0th element this means</span>\n            <span class=\"hljs-title\"># the least value is still somewhere to the right as we are still dealing with elements greater than nums[0]</span>\n            <span class=\"hljs-keyword\">if</span> nums[mid] > nums[<span class=\"hljs-params\">0</span>]:\n                left = mid + <span class=\"hljs-params\">1</span>\n            <span class=\"hljs-title\"># if nums[0] is greater than the mid value then this means the smallest value is somewhere to the left</span>\n            <span class=\"hljs-keyword\">else</span>:\n                right = mid - <span class=\"hljs-params\">1</span>\n\n```\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(logN)O(log N)O(logN)\n- 空间复杂度：O(1)O(1)O(1)\n\n### 二叉树\n\n对于一个给定的二叉树，其任意节点最多只有两个子节点。 从这个定义，我们似乎可以嗅出一点二分法的味道， 但是这并不是二分。但是，二叉树中却和二分有很多联系，我们来看一下。\n\n最简单的，如果这个二叉树是一个二叉搜索树（BST）。 那么实际上，在一个二叉搜索树种进行搜索的过程就是二分法。\n\n![](images/2bdd83b0659c73e8f1ac616bc76ab3c25d957f64.jpg)\n\n如上图，我们需要在这样一个二叉搜索树中搜索 7。那么我们的搜索路径则会是 8 -> 3 -> 6 -> 7，这也是一种二分法。只不过相比于普通的**有序序列查找给定值**二分， 其时间复杂度的下界更差，原因在于二叉搜索树并不一定是二叉平衡树。\n\n上面讲了二叉搜索树，我们再来看一种同样特殊的树 - 完全二叉树。 如果我们给一颗完全二叉树的所有节点进行编号（二进制），依次为 01,10,11, ...。\n\n![](images/e153469846858cc7db83b72d46525c425dc8354e.jpg)\n\n那么实际上，最后一行的编号就是从根节点到该节点的路径。 其中 0 表示向左， 1 表示向右。(第一位数字不用)。 我们以最后一行的 101 为例，我们需要执行一次左，然后一次右。\n\n![](images/c3611ad9aa9acd8a8bf4a19cbdc70bf1932a8f20.jpg)\n\n其实原理也不难，如果你用数组表示过完全二叉树，那么就很容易理解。 我们可以发现， 父节点的编号都是左节点的二倍，并且都是右节点的二倍 + 1。从二进制的角度来看就是：**父节点的编号左移一位就是左节点的编号，左移一位 + 1 就是右节点的编号**。 因此反过来， 知道了子节点的最后一位，我们就能知道它是父节点的左节点还是右节点啦。\n\n## 题目推荐\n\n- [875. 爱吃香蕉的珂珂](https://leetcode-cn.com/problems/koko-eating-bananas/)\n- [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/description/)\n- [354. 俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes/)\n- [面试题 17.08. 马戏团人塔](https://leetcode-cn.com/problems/circus-tower-lcci/)\n\n> 后面三个题建议一起做\n\n## 总结\n\n二分查找是一种非常重要且难以掌握的核心算法，大家一定要好好领会。有的题目直接二分就可以了，有的题目二分只是其中一个环节。不管是哪种，都需要我们对二分的思想和代码模板非常熟悉才可以。\n\n二分查找的基本题型有：\n\n- 查找满足条件的元素，返回对应索引\n- 如果存在多个满足条件的元素，返回最左边满足条件的索引。\n- 如果存在多个满足条件的元素，返回最右边满足条件的索引。\n- 数组不是整体有序的。 比如先升序再降序，或者先降序再升序。\n- 将一维数组变成二维数组。\n- 局部有序查找最大（最小）元素\n- 。。。\n\n不管是哪一种类型，我们的思维框架都是类似的，都是：\n\n- 先定义**搜索区间**（非常重要）\n- 根据搜索区间定义循环结束条件\n- 取中间元素和目标元素做对比（目标元素可能是需要找的元素或者是数组第一个，最后一个元素等）（非常重要）\n- 根据比较的结果收缩区间，舍弃非法解（也就是二分）\n\n> 如果是整体有序通常只需要 nums\\[mid\\] 和 target 比较即可。如果是局部有序，则可能需要与其周围的特定元素进行比较。\n\n大家可以使用这个思维框架并结合本文介绍的几种题型进行练习，必要的情况可以使用我提供的解题模板，提供解题速度的同时，有效地降低出错的概率。\n\n特别需要注意的是**有无重复元素对二分算法影响很大**，我们需要小心对待。"},"options":{}}
</script>

<script src="https://jsdelivr.topthink.com/npm/lodash@4.17/lodash.min.js"></script>

<script src="https://jsdelivr.topthink.com/npm/react@17/umd/react.production.min.js"></script>

<script src="https://jsdelivr.topthink.com/npm/react-dom@17/umd/react-dom.production.min.js"></script>

<script src="asset/index.js"></script>

<script src="asset/plugins/theme-default/index.js"></script>

<script type="text/javascript">
    TopWrite.bootstrap();
</script>


</body></html>