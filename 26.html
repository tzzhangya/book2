<!DOCTYPE html><html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>《日程安排》专题 - 未命名文档</title>
    
<link rel="stylesheet" type="text/css" href="asset/plugins/theme-default/829.index.css"></head>
<body>
<div id="root"><div><div class="Loading__loading___1m_fZ"><div class="Loading__bar___21yOt" style="background: rgb(33, 186, 69); width: 0%; display: none;"><div class="Loading__peg___3Y_28"></div></div></div><div class="Loading__spinner___11Pm4"><div class="Loading__icon___3OOyu" style="display: none; border-color: #21ba45;"></div></div></div><div class="body--4cb30f26 with-sidebar--64a35dd2"><div class="sidebar--92cdcd4d"><div class="header--fbbaa9f2"><a class="title--8b08af4e" href="."><img src="logo.png" width="30" height="30">未命名文档</a><div class="search--783540ff"><input type="search" placeholder="请输入搜索关键词……" value=""></div></div><div class="body--4cb30f26"><div class="summary--54538abb"><ul><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="1.html">Introduction</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="12" width="12" xmlns="http://www.w3.org/2000/svg"><path d="M12.14 8.753l-5.482 4.796c-.646.566-1.658.106-1.658-.753V3.204a1 1 0 011.659-.753l5.48 4.796a1 1 0 010 1.506z"></path></svg></span><a class="text--59d9f9de" href="2.html">第一章 - 算法专题</a></div><ul><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="3.html">数据结构</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="4.html">基础算法</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="5.html">二叉树的遍历</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="6.html">动态规划</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="7.html">哈夫曼编码和游程编码</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="8.html">布隆过滤器</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="9.html">字符串问题</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="10.html">前缀树专题</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="11.html">《贪婪策略》专题</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="12.html">《深度优先遍历》专题</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="13.html">滑动窗口（思路 + 模板）</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="14.html">位运算</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="15.html">设计题</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="16.html">小岛问题</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="17.html">最大公约数</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="18.html">并查集</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="19.html">前缀和</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="20.html">平衡二叉树专题</a></div></li></ul></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="12" width="12" xmlns="http://www.w3.org/2000/svg"><path d="M12.14 8.753l-5.482 4.796c-.646.566-1.658.106-1.658-.753V3.204a1 1 0 011.659-.753l5.48 4.796a1 1 0 010 1.506z"></path></svg></span><a class="text--59d9f9de" href="21.html">第二章 - 91 天学算法</a></div><ul><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="22.html">第一期讲义-二分法</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="23.html">第一期讲义-双指针</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="24.html">第二期</a></div></li></ul></li><li class="open--57a75e6f"><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="12" width="12" xmlns="http://www.w3.org/2000/svg"><path d="M7.247 11.14L2.451 5.658C1.885 5.013 2.345 4 3.204 4h9.592a1 1 0 01.753 1.659l-4.796 5.48a1 1 0 01-1.506 0z"></path></svg></span><a class="text--59d9f9de" href="25.html">第三章 - 精选题解</a></div><ul><li class=""><div class="item--9cbf6482 active--c30e4dc0"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="26.html">《日程安排》专题</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="27.html">《构造二叉树》专题</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="28.html">字典序列删除</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="29.html">百度的算法面试题 * 祖玛游戏</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="30.html">西法的刷题秘籍】一次搞定前缀和</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="31.html">字节跳动的算法面试题是什么难度？</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="32.html">字节跳动的算法面试题是什么难度？（第二弹）</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="33.html">《我是你的妈妈呀》 * 第一期</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="34.html">一文带你看懂二叉树的序列化</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="35.html">穿上衣服我就不认识你了？来聊聊最长上升子序列</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="36.html">你的衣服我扒了 * 《最长公共子序列》</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="37.html">一文看懂《最大子序列和问题》</a></div></li></ul></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="12" width="12" xmlns="http://www.w3.org/2000/svg"><path d="M12.14 8.753l-5.482 4.796c-.646.566-1.658.106-1.658-.753V3.204a1 1 0 011.659-.753l5.48 4.796a1 1 0 010 1.506z"></path></svg></span><a class="text--59d9f9de" href="38.html">第四章 - 高频考题（简单）</a></div><ul><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="39.html">面试题 17.12. BiNode</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="40.html">0001. 两数之和</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="41.html">0020. 有效的括号</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="42.html">0021. 合并两个有序链表</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="43.html">0026. 删除排序数组中的重复项</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="44.html">0053. 最大子序和</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="45.html">0088. 合并两个有序数组</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="46.html">0101. 对称二叉树</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="47.html">0104. 二叉树的最大深度</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="48.html">0108. 将有序数组转换为二叉搜索树</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="49.html">0121. 买卖股票的最佳时机</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="50.html">0122. 买卖股票的最佳时机 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="51.html">0125. 验证回文串</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="52.html">0136. 只出现一次的数字</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="53.html">0155. 最小栈</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="54.html">0167. 两数之和 II * 输入有序数组</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="55.html">0169. 多数元素</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="56.html">0172. 阶乘后的零</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="57.html">0190. 颠倒二进制位</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="58.html">0191. 位1的个数</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="59.html">0198. 打家劫舍</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="60.html">0203. 移除链表元素</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="61.html">0206. 反转链表</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="62.html">0219. 存在重复元素 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="63.html">0226. 翻转二叉树</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="64.html">0232. 用栈实现队列</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="65.html">0263. 丑数</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="66.html">0283. 移动零</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="67.html">0342. 4的幂</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="68.html">0349. 两个数组的交集</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="69.html">0371. 两整数之和</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="70.html">0437. 路径总和 III</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="71.html">0455. 分发饼干</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="72.html">0575. 分糖果</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="73.html">0874. 模拟行走机器人</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="74.html">1260. 二维网格迁移</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="75.html">1332. 删除回文子序列</a></div></li></ul></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="12" width="12" xmlns="http://www.w3.org/2000/svg"><path d="M12.14 8.753l-5.482 4.796c-.646.566-1.658.106-1.658-.753V3.204a1 1 0 011.659-.753l5.48 4.796a1 1 0 010 1.506z"></path></svg></span><a class="text--59d9f9de" href="76.html">第五章 - 高频考题（中等）</a></div><ul><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="77.html">0002. 两数相加</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="78.html">0003. 无重复字符的最长子串</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="79.html">0005. 最长回文子串</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="80.html">0011. 盛最多水的容器</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="81.html">0015. 三数之和</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="82.html">0017. 电话号码的字母组合</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="83.html">0019. 删除链表的倒数第N个节点</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="84.html">0022. 括号生成</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="85.html">0024. 两两交换链表中的节点</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="86.html">0029. 两数相除</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="87.html">0031. 下一个排列</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="88.html">0033. 搜索旋转排序数组</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="89.html">0039. 组合总和</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="90.html">0040. 组合总和 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="91.html">0046. 全排列</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="92.html">0047. 全排列 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="93.html">0048. 旋转图像</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="94.html">0049. 字母异位词分组</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="95.html">0050. Pow(x, n)</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="96.html">0055. 跳跃游戏</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="97.html">0056. 合并区间</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="98.html">0060. 第k个排列</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="99.html">0062. 不同路径</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="100.html">0073. 矩阵置零</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="101.html">0075. 颜色分类</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="102.html">0078. 子集</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="103.html">0079. 单词搜索</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="104.html">0080. 删除排序数组中的重复项 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="105.html">0086. 分隔链表</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="106.html">0090. 子集 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="107.html">0091. 解码方法</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="108.html">0092. 反转链表 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="109.html">0094. 二叉树的中序遍历</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="110.html">0095. 不同的二叉搜索树 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="111.html">0096. 不同的二叉搜索树</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="112.html">0098. 验证二叉搜索树</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="113.html">0102. 二叉树的层序遍历</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="114.html">0103. 二叉树的锯齿形层次遍历</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="115.html">105. 从前序与中序遍历序列构造二叉树</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="116.html">0113. 路径总和 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="117.html">0129. 求根到叶子节点数字之和</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="118.html">0130. 被围绕的区域</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="119.html">0131. 分割回文串</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="120.html">0139. 单词拆分</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="121.html">0144. 二叉树的前序遍历</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="122.html">0150. 逆波兰表达式求值</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="123.html">0152. 乘积最大子数组</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="124.html">0199. 二叉树的右视图</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="125.html">0200. 岛屿数量</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="126.html">0201. 数字范围按位与</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="127.html">0208. 实现 Trie (前缀树)</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="128.html">0209. 长度最小的子数组</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="129.html">0211. 添加与搜索单词 * 数据结构设计</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="130.html">0215. 数组中的第K个最大元素</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="131.html">0221. 最大正方形</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="132.html">0229. 求众数 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="133.html">0230. 二叉搜索树中第K小的元素</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="134.html">0236. 二叉树的最近公共祖先</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="135.html">0238. 除自身以外数组的乘积</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="136.html">0240. 搜索二维矩阵 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="137.html">0279. 完全平方数</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="138.html">0309. 最佳买卖股票时机含冷冻期</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="139.html">0322. 零钱兑换</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="140.html">0328. 奇偶链表</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="141.html">0334. 递增的三元子序列</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="142.html">0337. 打家劫舍 III</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="143.html">0343. 整数拆分</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="144.html">0365. 水壶问题</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="145.html">0378. 有序矩阵中第K小的元素</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="146.html">0380. 常数时间插入、删除和获取随机元素</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="147.html">0416. 分割等和子集</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="148.html">0445. 两数相加 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="149.html">0454. 四数相加 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="150.html">0494. 目标和</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="151.html">0516. 最长回文子序列</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="152.html">0518. 零钱兑换 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="153.html">0547. 朋友圈</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="154.html">0560. 和为K的子数组</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="155.html">0609. 在系统中查找重复文件</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="156.html">0611. 有效三角形的个数</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="157.html">0718. 最长重复子数组</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="158.html">0754. 到达终点数字</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="159.html">0785. 判断二分图</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="160.html">0820. 单词的压缩编码</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="161.html">0875. 爱吃香蕉的珂珂</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="162.html">0877. 石子游戏</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="163.html">0886. 可能的二分法</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="164.html">0900. RLE 迭代器</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="165.html">0912. 排序数组</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="166.html">0935. 骑士拨号器</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="167.html">1011. 在 D 天内送达包裹的能力</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="168.html">1014. 最佳观光组合</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="169.html">1015. 可被 K 整除的最小整数</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="170.html">1019. 链表中的下一个更大节点</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="171.html">1020. 飞地的数量</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="172.html">1023. 驼峰式匹配</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="173.html">1031. 两个非重叠子数组的最大和</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="174.html">1104. 二叉树寻路</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="175.html">1131.绝对值表达式的最大值</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="176.html">1186. 删除一次得到子数组最大和</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="177.html">1218. 最长定差子序列</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="178.html">1227. 飞机座位分配概率</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="179.html">1261. 在受污染的二叉树中查找元素</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="180.html">1262. 可被三整除的最大和</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="181.html">1297. 子串的最大出现次数</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="182.html">1310. 子数组异或查询</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="183.html">1334. 阈值距离内邻居最少的城市</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="184.html">1371.每个元音包含偶数次的最长子字符串</a></div></li></ul></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="12" width="12" xmlns="http://www.w3.org/2000/svg"><path d="M12.14 8.753l-5.482 4.796c-.646.566-1.658.106-1.658-.753V3.204a1 1 0 011.659-.753l5.48 4.796a1 1 0 010 1.506z"></path></svg></span><a class="text--59d9f9de" href="185.html">第六章 - 高频考题（困难）</a></div><ul><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="186.html">0004. 寻找两个正序数组的中位数</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="187.html">0023. 合并K个升序链表</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="188.html">0025. K 个一组翻转链表</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="189.html">0030. 串联所有单词的子串</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="190.html">0032. 最长有效括号</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="191.html">0042. 接雨水</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="192.html">0052. N皇后 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="193.html">0084. 柱状图中最大的矩形</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="194.html">0085. 最大矩形</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="195.html">0124. 二叉树中的最大路径和</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="196.html">0128. 最长连续序列</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="197.html">0145. 二叉树的后序遍历</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="198.html">0212. 单词搜索 II</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="199.html">0239. 滑动窗口最大值</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="200.html">0295. 数据流的中位数</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="201.html">0301. 删除无效的括号</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="202.html">0312. 戳气球</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="203.html">0335. 路径交叉</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="204.html">0460. LFU缓存</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="205.html">0472. 连接词</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="206.html">0488. 祖玛游戏</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="207.html">0493. 翻转对</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="208.html">0887. 鸡蛋掉落</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="209.html">0895. 最大频率栈</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="210.html">1032. 字符流</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="211.html">1168. 水资源分配优化</a></div></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="212.html">1449. 数位成本和为目标值的最大数字</a></div></li></ul></li><li class=""><div class="item--9cbf6482"><div class="whole--9f70f484"></div><span class="space--8603ccbf"></span><a class="text--59d9f9de" href="213.html">后序</a></div></li></ul></div></div><div class="copyright--2aa57f2d">本文档使用 <a href="https://x.topthink.com" target="_blank">顶想云</a> 构建</div></div><div class="main--6aaec551"><div class="toolbar--af3e5b9e"><h1>《日程安排》专题</h1></div><div class="markdown-body"><h1>《日程安排》专题</h1><p>《我的日程安排表》截止目前（2020-02-03）在 LeetCode 上一共有三道题，其中两个中等难度，一个困难难度,分别是：</p><ul><li><a href="https://leetcode-cn.com/problems/my-calendar-i" target="_blank">729. 我的日程安排表 I</a></li><li><a href="https://leetcode-cn.com/problems/my-calendar-ii" target="_blank">731. 我的日程安排表 II</a></li><li><a href="https://leetcode-cn.com/problems/my-calendar-iii" target="_blank">732. 我的日程安排表 III</a></li></ul><p>另外 LeetCode 上有一个类似的系列《会议室》，截止目前（2020-02-03）有两道题目。其中一个简单一个中等，分别是：</p><ul><li><a href="https://leetcode-cn.com/problems/meeting-rooms/" target="_blank">252. 会议室</a></li><li><a href="https://leetcode-cn.com/problems/meeting-rooms-ii/" target="_blank">253. 会议室 II</a></li></ul><p>今天我们就来攻克它们。</p><h1>729. 我的日程安排表 I</h1><h2>题目地址</h2><p><a href="https://leetcode-cn.com/problems/my-calendar-i" target="_blank">https://leetcode-cn.com/problems/my-calendar-i</a></p><h2>题目描述</h2><p>实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内没有其他安排，则可以存储这个新的日程安排。</p><p>MyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数 x 的范围为， start &lt;= x &lt; end。</p><p>当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生重复预订。</p><p>每次调用 MyCalendar.book 方法时，如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 true。否则，返回 false 并且不要将该日程安排添加到日历中。</p><p>请按照以下步骤调用 MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)</p><p>示例 1:</p><p>MyCalendar(); MyCalendar.book(10, 20); // returns true MyCalendar.book(15, 25); // returns false MyCalendar.book(20, 30); // returns true 解释: 第一个日程安排可以添加到日历中. 第二个日程安排不能添加到日历中，因为时间 15 已经被第一个日程安排预定了。 第三个日程安排可以添加到日历中，因为第一个日程安排并不包含时间 20 。 说明:</p><p>每个测试用例，调用 MyCalendar.book 函数最多不超过 100 次。 调用函数 MyCalendar.book(start, end)时， start 和 end 的取值范围为 [0, 10^9]。</p><h2>暴力法</h2><h3>思路</h3><p>首先我们考虑暴力法。每插入一个元素我们都判断其是否和已有的<code>所有</code>课程重叠。</p><p>我们定一个函数<code>intersected(calendar, calendars)</code>，其中 calendar 是即将要插入的课程，calendars 是已经插入的课程。 只要 calendar 和 calendars 中的任何一个课程有交叉，我们就返回 True，否则返回 False。</p><p>对于两个 calendar，我们的判断逻辑都是一样的。假设连个 calendar 分别是<code>[s1, e1]</code>和<code>[s2, e2]</code>。那么如果<code>s1 &gt;= e2 or s2 &lt;= e1</code>, 则两个课程没有交叉，可以预定，否则不可以。如图，1，2，3 可以预定，剩下的不可以。</p><p><img src="images/3121ece0a7eb596ad3a0afc97468e8e618bac72c.jpg" alt=""></p><p>代码是这样的：</p><pre><code>&lt;pre class="calibre18"&gt;```
    &lt;span class="hljs-function"&gt;&lt;span class="hljs-keyword"&gt;def&lt;/span&gt; &lt;span class="hljs-title"&gt;intersected&lt;/span&gt;&lt;span class="hljs-params"&gt;(calendar, calendars)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class="hljs-keyword"&gt;for&lt;/span&gt; [start, end] &lt;span class="hljs-keyword"&gt;in&lt;/span&gt; calendars:
            &lt;span class="hljs-keyword"&gt;if&lt;/span&gt; calendar[&lt;span class="hljs-params"&gt;0&lt;/span&gt;] &gt;= end &lt;span class="hljs-keyword"&gt;or&lt;/span&gt; calendar[&lt;span class="hljs-params"&gt;1&lt;/span&gt;] &lt;= start:
                &lt;span class="hljs-keyword"&gt;continue&lt;/span&gt;
            &lt;span class="hljs-keyword"&gt;else&lt;/span&gt;:
                &lt;span class="hljs-keyword"&gt;return&lt;/span&gt; &lt;span class="hljs-keyword"&gt;True&lt;/span&gt;

        &lt;span class="hljs-keyword"&gt;return&lt;/span&gt; &lt;span class="hljs-keyword"&gt;False&lt;/span&gt;

</code></pre><pre><code>
复杂度分析：

- 时间复杂度：O(N2)O(N^2)O(N2)。N 指的是日常安排的数量，对于每个新的日常安排，我们检查新的日常安排是否发生冲突来决定是否可以预订新的日常安排。
- 空间复杂度: O(N)O(N)O(N)。

这个代码写出来之后整体代码就呼之欲出了，全部代码见下方代码部分。

### 代码

代码支持 Python3:

Python3 Code:

</code></pre></div><div class="navigation--93943883"><span class="prev--8f062b74">上一篇:<a href="25.html">第三章 - 精选题解</a></span><span class="next--1623c556">下一篇:<a href="27.html">《构造二叉树》专题</a></span></div></div></div></div>
<script type="application/payload+json">
{"book":{"id":"219169308@github"},"summary":[{"title":"","articles":[{"title":"Introduction","ref":"1.md","path":"1.html","children":[]},{"title":"第一章 - 算法专题","ref":"2.md","path":"2.html","children":[{"title":"数据结构","ref":"3.md","path":"3.html","children":[]},{"title":"基础算法","ref":"4.md","path":"4.html","children":[]},{"title":"二叉树的遍历","ref":"5.md","path":"5.html","children":[]},{"title":"动态规划","ref":"6.md","path":"6.html","children":[]},{"title":"哈夫曼编码和游程编码","ref":"7.md","path":"7.html","children":[]},{"title":"布隆过滤器","ref":"8.md","path":"8.html","children":[]},{"title":"字符串问题","ref":"9.md","path":"9.html","children":[]},{"title":"前缀树专题","ref":"10.md","path":"10.html","children":[]},{"title":"《贪婪策略》专题","ref":"11.md","path":"11.html","children":[]},{"title":"《深度优先遍历》专题","ref":"12.md","path":"12.html","children":[]},{"title":"滑动窗口（思路 + 模板）","ref":"13.md","path":"13.html","children":[]},{"title":"位运算","ref":"14.md","path":"14.html","children":[]},{"title":"设计题","ref":"15.md","path":"15.html","children":[]},{"title":"小岛问题","ref":"16.md","path":"16.html","children":[]},{"title":"最大公约数","ref":"17.md","path":"17.html","children":[]},{"title":"并查集","ref":"18.md","path":"18.html","children":[]},{"title":"前缀和","ref":"19.md","path":"19.html","children":[]},{"title":"平衡二叉树专题","ref":"20.md","path":"20.html","children":[]}]},{"title":"第二章 - 91 天学算法","ref":"21.md","path":"21.html","children":[{"title":"第一期讲义-二分法","ref":"22.md","path":"22.html","children":[]},{"title":"第一期讲义-双指针","ref":"23.md","path":"23.html","children":[]},{"title":"第二期","ref":"24.md","path":"24.html","children":[]}]},{"title":"第三章 - 精选题解","ref":"25.md","path":"25.html","children":[{"title":"《日程安排》专题","ref":"26.md","path":"26.html","children":[]},{"title":"《构造二叉树》专题","ref":"27.md","path":"27.html","children":[]},{"title":"字典序列删除","ref":"28.md","path":"28.html","children":[]},{"title":"百度的算法面试题 * 祖玛游戏","ref":"29.md","path":"29.html","children":[]},{"title":"西法的刷题秘籍】一次搞定前缀和","ref":"30.md","path":"30.html","children":[]},{"title":"字节跳动的算法面试题是什么难度？","ref":"31.md","path":"31.html","children":[]},{"title":"字节跳动的算法面试题是什么难度？（第二弹）","ref":"32.md","path":"32.html","children":[]},{"title":"《我是你的妈妈呀》 * 第一期","ref":"33.md","path":"33.html","children":[]},{"title":"一文带你看懂二叉树的序列化","ref":"34.md","path":"34.html","children":[]},{"title":"穿上衣服我就不认识你了？来聊聊最长上升子序列","ref":"35.md","path":"35.html","children":[]},{"title":"你的衣服我扒了 * 《最长公共子序列》","ref":"36.md","path":"36.html","children":[]},{"title":"一文看懂《最大子序列和问题》","ref":"37.md","path":"37.html","children":[]}]},{"title":"第四章 - 高频考题（简单）","ref":"38.md","path":"38.html","children":[{"title":"面试题 17.12. BiNode","ref":"39.md","path":"39.html","children":[]},{"title":"0001. 两数之和","ref":"40.md","path":"40.html","children":[]},{"title":"0020. 有效的括号","ref":"41.md","path":"41.html","children":[]},{"title":"0021. 合并两个有序链表","ref":"42.md","path":"42.html","children":[]},{"title":"0026. 删除排序数组中的重复项","ref":"43.md","path":"43.html","children":[]},{"title":"0053. 最大子序和","ref":"44.md","path":"44.html","children":[]},{"title":"0088. 合并两个有序数组","ref":"45.md","path":"45.html","children":[]},{"title":"0101. 对称二叉树","ref":"46.md","path":"46.html","children":[]},{"title":"0104. 二叉树的最大深度","ref":"47.md","path":"47.html","children":[]},{"title":"0108. 将有序数组转换为二叉搜索树","ref":"48.md","path":"48.html","children":[]},{"title":"0121. 买卖股票的最佳时机","ref":"49.md","path":"49.html","children":[]},{"title":"0122. 买卖股票的最佳时机 II","ref":"50.md","path":"50.html","children":[]},{"title":"0125. 验证回文串","ref":"51.md","path":"51.html","children":[]},{"title":"0136. 只出现一次的数字","ref":"52.md","path":"52.html","children":[]},{"title":"0155. 最小栈","ref":"53.md","path":"53.html","children":[]},{"title":"0167. 两数之和 II * 输入有序数组","ref":"54.md","path":"54.html","children":[]},{"title":"0169. 多数元素","ref":"55.md","path":"55.html","children":[]},{"title":"0172. 阶乘后的零","ref":"56.md","path":"56.html","children":[]},{"title":"0190. 颠倒二进制位","ref":"57.md","path":"57.html","children":[]},{"title":"0191. 位1的个数","ref":"58.md","path":"58.html","children":[]},{"title":"0198. 打家劫舍","ref":"59.md","path":"59.html","children":[]},{"title":"0203. 移除链表元素","ref":"60.md","path":"60.html","children":[]},{"title":"0206. 反转链表","ref":"61.md","path":"61.html","children":[]},{"title":"0219. 存在重复元素 II","ref":"62.md","path":"62.html","children":[]},{"title":"0226. 翻转二叉树","ref":"63.md","path":"63.html","children":[]},{"title":"0232. 用栈实现队列","ref":"64.md","path":"64.html","children":[]},{"title":"0263. 丑数","ref":"65.md","path":"65.html","children":[]},{"title":"0283. 移动零","ref":"66.md","path":"66.html","children":[]},{"title":"0342. 4的幂","ref":"67.md","path":"67.html","children":[]},{"title":"0349. 两个数组的交集","ref":"68.md","path":"68.html","children":[]},{"title":"0371. 两整数之和","ref":"69.md","path":"69.html","children":[]},{"title":"0437. 路径总和 III","ref":"70.md","path":"70.html","children":[]},{"title":"0455. 分发饼干","ref":"71.md","path":"71.html","children":[]},{"title":"0575. 分糖果","ref":"72.md","path":"72.html","children":[]},{"title":"0874. 模拟行走机器人","ref":"73.md","path":"73.html","children":[]},{"title":"1260. 二维网格迁移","ref":"74.md","path":"74.html","children":[]},{"title":"1332. 删除回文子序列","ref":"75.md","path":"75.html","children":[]}]},{"title":"第五章 - 高频考题（中等）","ref":"76.md","path":"76.html","children":[{"title":"0002. 两数相加","ref":"77.md","path":"77.html","children":[]},{"title":"0003. 无重复字符的最长子串","ref":"78.md","path":"78.html","children":[]},{"title":"0005. 最长回文子串","ref":"79.md","path":"79.html","children":[]},{"title":"0011. 盛最多水的容器","ref":"80.md","path":"80.html","children":[]},{"title":"0015. 三数之和","ref":"81.md","path":"81.html","children":[]},{"title":"0017. 电话号码的字母组合","ref":"82.md","path":"82.html","children":[]},{"title":"0019. 删除链表的倒数第N个节点","ref":"83.md","path":"83.html","children":[]},{"title":"0022. 括号生成","ref":"84.md","path":"84.html","children":[]},{"title":"0024. 两两交换链表中的节点","ref":"85.md","path":"85.html","children":[]},{"title":"0029. 两数相除","ref":"86.md","path":"86.html","children":[]},{"title":"0031. 下一个排列","ref":"87.md","path":"87.html","children":[]},{"title":"0033. 搜索旋转排序数组","ref":"88.md","path":"88.html","children":[]},{"title":"0039. 组合总和","ref":"89.md","path":"89.html","children":[]},{"title":"0040. 组合总和 II","ref":"90.md","path":"90.html","children":[]},{"title":"0046. 全排列","ref":"91.md","path":"91.html","children":[]},{"title":"0047. 全排列 II","ref":"92.md","path":"92.html","children":[]},{"title":"0048. 旋转图像","ref":"93.md","path":"93.html","children":[]},{"title":"0049. 字母异位词分组","ref":"94.md","path":"94.html","children":[]},{"title":"0050. Pow(x, n)","ref":"95.md","path":"95.html","children":[]},{"title":"0055. 跳跃游戏","ref":"96.md","path":"96.html","children":[]},{"title":"0056. 合并区间","ref":"97.md","path":"97.html","children":[]},{"title":"0060. 第k个排列","ref":"98.md","path":"98.html","children":[]},{"title":"0062. 不同路径","ref":"99.md","path":"99.html","children":[]},{"title":"0073. 矩阵置零","ref":"100.md","path":"100.html","children":[]},{"title":"0075. 颜色分类","ref":"101.md","path":"101.html","children":[]},{"title":"0078. 子集","ref":"102.md","path":"102.html","children":[]},{"title":"0079. 单词搜索","ref":"103.md","path":"103.html","children":[]},{"title":"0080. 删除排序数组中的重复项 II","ref":"104.md","path":"104.html","children":[]},{"title":"0086. 分隔链表","ref":"105.md","path":"105.html","children":[]},{"title":"0090. 子集 II","ref":"106.md","path":"106.html","children":[]},{"title":"0091. 解码方法","ref":"107.md","path":"107.html","children":[]},{"title":"0092. 反转链表 II","ref":"108.md","path":"108.html","children":[]},{"title":"0094. 二叉树的中序遍历","ref":"109.md","path":"109.html","children":[]},{"title":"0095. 不同的二叉搜索树 II","ref":"110.md","path":"110.html","children":[]},{"title":"0096. 不同的二叉搜索树","ref":"111.md","path":"111.html","children":[]},{"title":"0098. 验证二叉搜索树","ref":"112.md","path":"112.html","children":[]},{"title":"0102. 二叉树的层序遍历","ref":"113.md","path":"113.html","children":[]},{"title":"0103. 二叉树的锯齿形层次遍历","ref":"114.md","path":"114.html","children":[]},{"title":"105. 从前序与中序遍历序列构造二叉树","ref":"115.md","path":"115.html","children":[]},{"title":"0113. 路径总和 II","ref":"116.md","path":"116.html","children":[]},{"title":"0129. 求根到叶子节点数字之和","ref":"117.md","path":"117.html","children":[]},{"title":"0130. 被围绕的区域","ref":"118.md","path":"118.html","children":[]},{"title":"0131. 分割回文串","ref":"119.md","path":"119.html","children":[]},{"title":"0139. 单词拆分","ref":"120.md","path":"120.html","children":[]},{"title":"0144. 二叉树的前序遍历","ref":"121.md","path":"121.html","children":[]},{"title":"0150. 逆波兰表达式求值","ref":"122.md","path":"122.html","children":[]},{"title":"0152. 乘积最大子数组","ref":"123.md","path":"123.html","children":[]},{"title":"0199. 二叉树的右视图","ref":"124.md","path":"124.html","children":[]},{"title":"0200. 岛屿数量","ref":"125.md","path":"125.html","children":[]},{"title":"0201. 数字范围按位与","ref":"126.md","path":"126.html","children":[]},{"title":"0208. 实现 Trie (前缀树)","ref":"127.md","path":"127.html","children":[]},{"title":"0209. 长度最小的子数组","ref":"128.md","path":"128.html","children":[]},{"title":"0211. 添加与搜索单词 * 数据结构设计","ref":"129.md","path":"129.html","children":[]},{"title":"0215. 数组中的第K个最大元素","ref":"130.md","path":"130.html","children":[]},{"title":"0221. 最大正方形","ref":"131.md","path":"131.html","children":[]},{"title":"0229. 求众数 II","ref":"132.md","path":"132.html","children":[]},{"title":"0230. 二叉搜索树中第K小的元素","ref":"133.md","path":"133.html","children":[]},{"title":"0236. 二叉树的最近公共祖先","ref":"134.md","path":"134.html","children":[]},{"title":"0238. 除自身以外数组的乘积","ref":"135.md","path":"135.html","children":[]},{"title":"0240. 搜索二维矩阵 II","ref":"136.md","path":"136.html","children":[]},{"title":"0279. 完全平方数","ref":"137.md","path":"137.html","children":[]},{"title":"0309. 最佳买卖股票时机含冷冻期","ref":"138.md","path":"138.html","children":[]},{"title":"0322. 零钱兑换","ref":"139.md","path":"139.html","children":[]},{"title":"0328. 奇偶链表","ref":"140.md","path":"140.html","children":[]},{"title":"0334. 递增的三元子序列","ref":"141.md","path":"141.html","children":[]},{"title":"0337. 打家劫舍 III","ref":"142.md","path":"142.html","children":[]},{"title":"0343. 整数拆分","ref":"143.md","path":"143.html","children":[]},{"title":"0365. 水壶问题","ref":"144.md","path":"144.html","children":[]},{"title":"0378. 有序矩阵中第K小的元素","ref":"145.md","path":"145.html","children":[]},{"title":"0380. 常数时间插入、删除和获取随机元素","ref":"146.md","path":"146.html","children":[]},{"title":"0416. 分割等和子集","ref":"147.md","path":"147.html","children":[]},{"title":"0445. 两数相加 II","ref":"148.md","path":"148.html","children":[]},{"title":"0454. 四数相加 II","ref":"149.md","path":"149.html","children":[]},{"title":"0494. 目标和","ref":"150.md","path":"150.html","children":[]},{"title":"0516. 最长回文子序列","ref":"151.md","path":"151.html","children":[]},{"title":"0518. 零钱兑换 II","ref":"152.md","path":"152.html","children":[]},{"title":"0547. 朋友圈","ref":"153.md","path":"153.html","children":[]},{"title":"0560. 和为K的子数组","ref":"154.md","path":"154.html","children":[]},{"title":"0609. 在系统中查找重复文件","ref":"155.md","path":"155.html","children":[]},{"title":"0611. 有效三角形的个数","ref":"156.md","path":"156.html","children":[]},{"title":"0718. 最长重复子数组","ref":"157.md","path":"157.html","children":[]},{"title":"0754. 到达终点数字","ref":"158.md","path":"158.html","children":[]},{"title":"0785. 判断二分图","ref":"159.md","path":"159.html","children":[]},{"title":"0820. 单词的压缩编码","ref":"160.md","path":"160.html","children":[]},{"title":"0875. 爱吃香蕉的珂珂","ref":"161.md","path":"161.html","children":[]},{"title":"0877. 石子游戏","ref":"162.md","path":"162.html","children":[]},{"title":"0886. 可能的二分法","ref":"163.md","path":"163.html","children":[]},{"title":"0900. RLE 迭代器","ref":"164.md","path":"164.html","children":[]},{"title":"0912. 排序数组","ref":"165.md","path":"165.html","children":[]},{"title":"0935. 骑士拨号器","ref":"166.md","path":"166.html","children":[]},{"title":"1011. 在 D 天内送达包裹的能力","ref":"167.md","path":"167.html","children":[]},{"title":"1014. 最佳观光组合","ref":"168.md","path":"168.html","children":[]},{"title":"1015. 可被 K 整除的最小整数","ref":"169.md","path":"169.html","children":[]},{"title":"1019. 链表中的下一个更大节点","ref":"170.md","path":"170.html","children":[]},{"title":"1020. 飞地的数量","ref":"171.md","path":"171.html","children":[]},{"title":"1023. 驼峰式匹配","ref":"172.md","path":"172.html","children":[]},{"title":"1031. 两个非重叠子数组的最大和","ref":"173.md","path":"173.html","children":[]},{"title":"1104. 二叉树寻路","ref":"174.md","path":"174.html","children":[]},{"title":"1131.绝对值表达式的最大值","ref":"175.md","path":"175.html","children":[]},{"title":"1186. 删除一次得到子数组最大和","ref":"176.md","path":"176.html","children":[]},{"title":"1218. 最长定差子序列","ref":"177.md","path":"177.html","children":[]},{"title":"1227. 飞机座位分配概率","ref":"178.md","path":"178.html","children":[]},{"title":"1261. 在受污染的二叉树中查找元素","ref":"179.md","path":"179.html","children":[]},{"title":"1262. 可被三整除的最大和","ref":"180.md","path":"180.html","children":[]},{"title":"1297. 子串的最大出现次数","ref":"181.md","path":"181.html","children":[]},{"title":"1310. 子数组异或查询","ref":"182.md","path":"182.html","children":[]},{"title":"1334. 阈值距离内邻居最少的城市","ref":"183.md","path":"183.html","children":[]},{"title":"1371.每个元音包含偶数次的最长子字符串","ref":"184.md","path":"184.html","children":[]}]},{"title":"第六章 - 高频考题（困难）","ref":"185.md","path":"185.html","children":[{"title":"0004. 寻找两个正序数组的中位数","ref":"186.md","path":"186.html","children":[]},{"title":"0023. 合并K个升序链表","ref":"187.md","path":"187.html","children":[]},{"title":"0025. K 个一组翻转链表","ref":"188.md","path":"188.html","children":[]},{"title":"0030. 串联所有单词的子串","ref":"189.md","path":"189.html","children":[]},{"title":"0032. 最长有效括号","ref":"190.md","path":"190.html","children":[]},{"title":"0042. 接雨水","ref":"191.md","path":"191.html","children":[]},{"title":"0052. N皇后 II","ref":"192.md","path":"192.html","children":[]},{"title":"0084. 柱状图中最大的矩形","ref":"193.md","path":"193.html","children":[]},{"title":"0085. 最大矩形","ref":"194.md","path":"194.html","children":[]},{"title":"0124. 二叉树中的最大路径和","ref":"195.md","path":"195.html","children":[]},{"title":"0128. 最长连续序列","ref":"196.md","path":"196.html","children":[]},{"title":"0145. 二叉树的后序遍历","ref":"197.md","path":"197.html","children":[]},{"title":"0212. 单词搜索 II","ref":"198.md","path":"198.html","children":[]},{"title":"0239. 滑动窗口最大值","ref":"199.md","path":"199.html","children":[]},{"title":"0295. 数据流的中位数","ref":"200.md","path":"200.html","children":[]},{"title":"0301. 删除无效的括号","ref":"201.md","path":"201.html","children":[]},{"title":"0312. 戳气球","ref":"202.md","path":"202.html","children":[]},{"title":"0335. 路径交叉","ref":"203.md","path":"203.html","children":[]},{"title":"0460. LFU缓存","ref":"204.md","path":"204.html","children":[]},{"title":"0472. 连接词","ref":"205.md","path":"205.html","children":[]},{"title":"0488. 祖玛游戏","ref":"206.md","path":"206.html","children":[]},{"title":"0493. 翻转对","ref":"207.md","path":"207.html","children":[]},{"title":"0887. 鸡蛋掉落","ref":"208.md","path":"208.html","children":[]},{"title":"0895. 最大频率栈","ref":"209.md","path":"209.html","children":[]},{"title":"1032. 字符流","ref":"210.md","path":"210.html","children":[]},{"title":"1168. 水资源分配优化","ref":"211.md","path":"211.html","children":[]},{"title":"1449. 数位成本和为目标值的最大数字","ref":"212.md","path":"212.html","children":[]}]},{"title":"后序","ref":"213.md","path":"213.html","children":[]}]}],"config":{},"file":{"path":"26.html","content":"# 《日程安排》专题\n\n《我的日程安排表》截止目前（2020-02-03）在 LeetCode 上一共有三道题，其中两个中等难度，一个困难难度,分别是：\n\n- [729. 我的日程安排表 I](https://leetcode-cn.com/problems/my-calendar-i)\n- [731. 我的日程安排表 II](https://leetcode-cn.com/problems/my-calendar-ii)\n- [732. 我的日程安排表 III](https://leetcode-cn.com/problems/my-calendar-iii)\n\n另外 LeetCode 上有一个类似的系列《会议室》，截止目前（2020-02-03）有两道题目。其中一个简单一个中等，分别是：\n\n- [252. 会议室](https://leetcode-cn.com/problems/meeting-rooms/)\n- [253. 会议室 II](https://leetcode-cn.com/problems/meeting-rooms-ii/)\n\n今天我们就来攻克它们。\n\n# 729. 我的日程安排表 I\n\n## 题目地址\n\n<https://leetcode-cn.com/problems/my-calendar-i>\n\n## 题目描述\n\n实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内没有其他安排，则可以存储这个新的日程安排。\n\nMyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 \\[start, end), 实数 x 的范围为， start <= x < end。\n\n当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生重复预订。\n\n每次调用 MyCalendar.book 方法时，如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 true。否则，返回 false 并且不要将该日程安排添加到日历中。\n\n请按照以下步骤调用 MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)\n\n示例 1:\n\nMyCalendar(); MyCalendar.book(10, 20); // returns true MyCalendar.book(15, 25); // returns false MyCalendar.book(20, 30); // returns true 解释: 第一个日程安排可以添加到日历中. 第二个日程安排不能添加到日历中，因为时间 15 已经被第一个日程安排预定了。 第三个日程安排可以添加到日历中，因为第一个日程安排并不包含时间 20 。 说明:\n\n每个测试用例，调用 MyCalendar.book 函数最多不超过 100 次。 调用函数 MyCalendar.book(start, end)时， start 和 end 的取值范围为 \\[0, 10^9\\]。\n\n## 暴力法\n\n### 思路\n\n首先我们考虑暴力法。每插入一个元素我们都判断其是否和已有的`所有`课程重叠。\n\n我们定一个函数`intersected(calendar, calendars)`，其中 calendar 是即将要插入的课程，calendars 是已经插入的课程。 只要 calendar 和 calendars 中的任何一个课程有交叉，我们就返回 True，否则返回 False。\n\n对于两个 calendar，我们的判断逻辑都是一样的。假设连个 calendar 分别是`[s1, e1]`和`[s2, e2]`。那么如果`s1 >= e2 or s2 <= e1`, 则两个课程没有交叉，可以预定，否则不可以。如图，1，2，3 可以预定，剩下的不可以。\n\n![](images/3121ece0a7eb596ad3a0afc97468e8e618bac72c.jpg)\n\n代码是这样的：\n\n```\n<pre class=\"calibre18\">```\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">intersected</span><span class=\"hljs-params\">(calendar, calendars)</span>:</span>\n        <span class=\"hljs-keyword\">for</span> [start, end] <span class=\"hljs-keyword\">in</span> calendars:\n            <span class=\"hljs-keyword\">if</span> calendar[<span class=\"hljs-params\">0</span>] >= end <span class=\"hljs-keyword\">or</span> calendar[<span class=\"hljs-params\">1</span>] <= start:\n                <span class=\"hljs-keyword\">continue</span>\n            <span class=\"hljs-keyword\">else</span>:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">True</span>\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">False</span>\n\n```\n```\n\n复杂度分析：\n\n- 时间复杂度：O(N2)O(N^2)O(N2)。N 指的是日常安排的数量，对于每个新的日常安排，我们检查新的日常安排是否发生冲突来决定是否可以预订新的日常安排。\n- 空间复杂度: O(N)O(N)O(N)。\n\n这个代码写出来之后整体代码就呼之欲出了，全部代码见下方代码部分。\n\n### 代码\n\n代码支持 Python3:\n\nPython3 Code:\n\n```\n<pre class=\"calibre18\">```\n<span class=\"hljs-title\">#</span>\n<span class=\"hljs-title\"># @lc app=leetcode.cn id=729 lang=python3</span>\n<span class=\"hljs-title\">#</span>\n<span class=\"hljs-title\"># [729] 我的日程安排表 I</span>\n<span class=\"hljs-title\">#</span>\n\n<span class=\"hljs-title\"># @lc code=start</span>\n\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyCalendar</span>:</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span><span class=\"hljs-params\">(self)</span>:</span>\n        self.calendars = []\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">book</span><span class=\"hljs-params\">(self, start: int, end: int)</span> -> bool:</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">intersected</span><span class=\"hljs-params\">(calendar, calendars)</span>:</span>\n            <span class=\"hljs-keyword\">for</span> [start, end] <span class=\"hljs-keyword\">in</span> calendars:\n                <span class=\"hljs-keyword\">if</span> calendar[<span class=\"hljs-params\">0</span>] >= end <span class=\"hljs-keyword\">or</span> calendar[<span class=\"hljs-params\">1</span>] <= start:\n                    <span class=\"hljs-keyword\">continue</span>\n                <span class=\"hljs-keyword\">else</span>:\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">True</span>\n\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">False</span>\n        <span class=\"hljs-keyword\">if</span> intersected([start, end], self.calendars):\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">False</span>\n        self.calendars.append([start, end])\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">True</span>\n\n        <span class=\"hljs-title\"># Your MyCalendar object will be instantiated and called as such:</span>\n        <span class=\"hljs-title\"># obj = MyCalendar()</span>\n        <span class=\"hljs-title\"># param_1 = obj.book(start,end)</span>\n        <span class=\"hljs-title\"># @lc code=end</span>\n\n```\n```\n\n实际上我们还可以换个角度，上面的思路判断交叉部分我们考虑的是“如何不交叉”，剩下的就是交叉。我们也可以直接考虑交叉。还是上面的例子，如果两个课程交叉，那么一定满足`s1 < e2 and e1 > s2`。基于此，我们写出下面的代码。\n\n代码支持 Python3:\n\nPython3 Code:\n\n```\n<pre class=\"calibre18\">```\n<span class=\"hljs-title\">#</span>\n<span class=\"hljs-title\"># @lc app=leetcode.cn id=729 lang=python3</span>\n<span class=\"hljs-title\">#</span>\n<span class=\"hljs-title\"># [729] 我的日程安排表 I</span>\n<span class=\"hljs-title\">#</span>\n\n<span class=\"hljs-title\"># @lc code=start</span>\n\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyCalendar</span>:</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span><span class=\"hljs-params\">(self)</span>:</span>\n        self.calendars = []\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">book</span><span class=\"hljs-params\">(self, start: int, end: int)</span> -> bool:</span>\n        <span class=\"hljs-keyword\">for</span> s, e <span class=\"hljs-keyword\">in</span> self.calendars:\n            <span class=\"hljs-keyword\">if</span> start < e <span class=\"hljs-keyword\">and</span> end > s:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">False</span>\n        self.calendars.append([start, end])\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">True</span>\n\n        <span class=\"hljs-title\"># Your MyCalendar object will be instantiated and called as such:</span>\n        <span class=\"hljs-title\"># obj = MyCalendar()</span>\n        <span class=\"hljs-title\"># param_1 = obj.book(start,end)</span>\n        <span class=\"hljs-title\"># @lc code=end</span>\n\n```\n```\n\n## 二叉查找树法\n\n### 思路\n\n和上面思路类似，只不过我们每次都对 calendars 进行排序，那么我们可以通过二分查找日程安排的情况来检查新日常安排是否可以预订。如果每次插入之前都进行一次排序，那么时间复杂度会很高。如图，我们的\\[s1,e1\\], \\[s2,e2\\], \\[s3,e3\\] 是按照时间顺序排好的日程安排。我们现在要插入\\[s,e\\],我们使用二分查找，找到要插入的位置，然后和插入位置的课程进行一次比对即可，这部分的时间复杂度是 O(logN)O(logN)O(logN)。\n\n![](images/9c0211a6c341c555710ffc73a7f7f90a0b97bb95.jpg)\n\n我们考虑使用平衡二叉树来维护这种动态的变化，在最差的情况时间复杂度会退化到上述的O(N2)O(N^2)O(N2)，平均情况是O(NlogN)O(NlogN)O(NlogN)，其中 N 是已预订的日常安排数。\n\n![](images/7ba87da5c05145965838c8175f42f7c23127b3fe.jpg)\n\n### 代码\n\n代码支持 Python3:\n\nPython3 Code:\n\n```\n<pre class=\"calibre18\">```\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Node</span>:</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span><span class=\"hljs-params\">(self, start, end)</span>:</span>\n        self.start = start\n        self.end = end\n        self.left = self.right = <span class=\"hljs-keyword\">None</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(self, node)</span>:</span>\n        <span class=\"hljs-keyword\">if</span> node.start >= self.end:\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> self.right:\n                self.right = node\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">True</span>\n            <span class=\"hljs-keyword\">return</span> self.right.insert(node)\n        <span class=\"hljs-keyword\">elif</span> node.end <= self.start:\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> self.left:\n                self.left = node\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">True</span>\n            <span class=\"hljs-keyword\">return</span> self.left.insert(node)\n        <span class=\"hljs-keyword\">else</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">False</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyCalendar</span><span class=\"hljs-params\">(object)</span>:</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span><span class=\"hljs-params\">(self)</span>:</span>\n        self.root = <span class=\"hljs-keyword\">None</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">book</span><span class=\"hljs-params\">(self, start, end)</span>:</span>\n        <span class=\"hljs-keyword\">if</span> self.root <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">None</span>:\n            self.root = Node(start, end)\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">True</span>\n        <span class=\"hljs-keyword\">return</span> self.root.insert(Node(start, end))\n\n```\n```\n\n# 731. 我的日程安排表 II\n\n## 题目地址\n\n<https://leetcode-cn.com/problems/my-calendar-ii>\n\n## 题目描述\n\n实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内不会导致三重预订时，则可以存储这个新的日程安排。\n\nMyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 \\[start, end), 实数 x 的范围为， start <= x < end。\n\n当三个日程安排有一些时间上的交叉时（例如三个日程安排都在同一时间内），就会产生三重预订。\n\n每次调用 MyCalendar.book 方法时，如果可以将日程安排成功添加到日历中而不会导致三重预订，返回 true。否则，返回 false 并且不要将该日程安排添加到日历中。\n\n请按照以下步骤调用 MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)\n\n示例：\n\nMyCalendar(); MyCalendar.book(10, 20); // returns true MyCalendar.book(50, 60); // returns true MyCalendar.book(10, 40); // returns true MyCalendar.book(5, 15); // returns false MyCalendar.book(5, 10); // returns true MyCalendar.book(25, 55); // returns true 解释： 前两个日程安排可以添加至日历中。 第三个日程安排会导致双重预订，但可以添加至日历中。 第四个日程安排活动（5,15）不能添加至日历中，因为它会导致三重预订。 第五个日程安排（5,10）可以添加至日历中，因为它未使用已经双重预订的时间 10。 第六个日程安排（25,55）可以添加至日历中，因为时间 \\[25,40\\] 将和第三个日程安排双重预订； 时间 \\[40,50\\] 将单独预订，时间 \\[50,55）将和第二个日程安排双重预订。\n\n提示：\n\n每个测试用例，调用 MyCalendar.book 函数最多不超过 1000 次。 调用函数 MyCalendar.book(start, end)时， start 和 end 的取值范围为 \\[0, 10^9\\]。\n\n## 暴力法\n\n### 思路\n\n暴力法和上述思路类似。但是我们多维护一个数组 intersectedCalendars 用来存储**二次预定**的日程安排。如果课程第一次冲突，我们将其加入 intersectedCalendars，如果和 intersectedCalendars 也冲突了，说明出现了三次预定，我们直接返回 False。\n\n### 代码\n\n代码支持 Python3:\n\nPython3 Code:\n\n```\n<pre class=\"calibre18\">```\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyCalendarTwo</span>:</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span><span class=\"hljs-params\">(self)</span>:</span>\n        self.calendars = []\n        self.intersectedCalendars = []\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">book</span><span class=\"hljs-params\">(self, start: int, end: int)</span> -> bool:</span>\n        <span class=\"hljs-keyword\">for</span> [s, e] <span class=\"hljs-keyword\">in</span> self.intersectedCalendars:\n            <span class=\"hljs-keyword\">if</span> start < e <span class=\"hljs-keyword\">and</span> end > s:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">False</span>\n        <span class=\"hljs-keyword\">for</span> [s, e] <span class=\"hljs-keyword\">in</span> self.calendars:\n            <span class=\"hljs-keyword\">if</span> start < e <span class=\"hljs-keyword\">and</span> end > s:\n                self.intersectedCalendars.append([max(start, s), min(end, e)])\n        self.calendars.append([start, end])\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">True</span>\n\n```\n```\n\n## 二叉查找树法\n\n和上面的题目类似，我们仍然可以使用平衡二叉树来简化查找逻辑。具体可以参考[这个 discussion](https://leetcode.com/problems/my-calendar-ii/discuss/158747/Python-O(logN)>)\n\n每次插入之前我们都需要进行一次判断，判断是否可以插入。如果不可以插入，直接返回 False，否则我们进行一次插入。 插入的时候，如果和已有的相交了，我们判断是否之前已经相交了一次，如果是返回 False，否则返回 True。关于**如何判断是否和已有的相交**，我们可以在 node 节点增加一个字段的方式来标记，在这里我们使用 single\\_overlap，True 表示产生了二次预定，False 则表示没有产生过两次及以上的预定。\n\n## 代码\n\n代码支持 Python3:\n\nPython3 Code:\n\n```\n<pre class=\"calibre18\">```\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Node</span>:</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span><span class=\"hljs-params\">(self, start, end)</span>:</span>\n        self.start = start\n        self.end = end\n        self.left = <span class=\"hljs-keyword\">None</span>\n        self.right = <span class=\"hljs-keyword\">None</span>\n        self.single_overlap = <span class=\"hljs-keyword\">False</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyCalendarTwo</span>:</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span><span class=\"hljs-params\">(self)</span>:</span>\n        self.root = <span class=\"hljs-keyword\">None</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">book</span><span class=\"hljs-params\">(self, start, end)</span>:</span>\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> self.canInsert(start, end, self.root):\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">False</span>\n\n        self.root = self.insert(start, end, self.root)\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">True</span>\n\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">canInsert</span><span class=\"hljs-params\">(self, start, end, root)</span>:</span>\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> root:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">True</span>\n\n        <span class=\"hljs-keyword\">if</span> start >= end:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">True</span>\n\n        <span class=\"hljs-keyword\">if</span> end <= root.start:\n            <span class=\"hljs-keyword\">return</span> self.canInsert(start, end, root.left)\n\n        <span class=\"hljs-keyword\">elif</span> start >= root.end:\n            <span class=\"hljs-keyword\">return</span> self.canInsert(start, end, root.right)\n\n        <span class=\"hljs-keyword\">else</span>:\n            <span class=\"hljs-keyword\">if</span> root.single_overlap:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">False</span>\n            <span class=\"hljs-keyword\">elif</span> start >= root.start <span class=\"hljs-keyword\">and</span> end <= root.end:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">True</span>\n            <span class=\"hljs-keyword\">else</span>:\n                <span class=\"hljs-keyword\">return</span> self.canInsert(start, root.start, root.left) <span class=\"hljs-keyword\">and</span> self.canInsert(root.end, end, root.right)\n\n\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(self, start, end, root)</span>:</span>\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> root:\n            root = Node(start, end)\n            <span class=\"hljs-keyword\">return</span> root\n\n        <span class=\"hljs-keyword\">if</span> start >= end:\n            <span class=\"hljs-keyword\">return</span> root\n\n        <span class=\"hljs-keyword\">if</span> start >= root.end:\n            root.right = self.insert(start, end, root.right)\n\n        <span class=\"hljs-keyword\">elif</span> end <= root.start:\n            root.left = self.insert(start, end, root.left)\n\n        <span class=\"hljs-keyword\">else</span>:\n            root.single_overlap = <span class=\"hljs-keyword\">True</span>\n            a = min(root.start, start)\n            b = max(root.start, start)\n            c = min(root.end, end)\n            d = max(root.end, end)\n            root.start, root.end = b, c\n            root.left, root.right = self.insert(a, b, root.left), self.insert(c, d, root.right)\n\n        <span class=\"hljs-keyword\">return</span> root\n\n<span class=\"hljs-title\"># Your MyCalendarTwo object will be instantiated and called as such:</span>\n<span class=\"hljs-title\"># obj = MyCalendarTwo()</span>\n<span class=\"hljs-title\"># param_1 = obj.book(start,end)</span>\n\n```\n```\n\n# 732. 我的日程安排表 III\n\n## 题目地址\n\n<https://leetcode-cn.com/problems/my-calendar-iii/>\n\n## 题目描述\n\n实现一个 MyCalendar 类来存放你的日程安排，你可以一直添加新的日程安排。\n\nMyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 \\[start, end), 实数 x 的范围为， start <= x < end。\n\n当 K 个日程安排有一些时间上的交叉时（例如 K 个日程安排都在同一时间内），就会产生 K 次预订。\n\n每次调用 MyCalendar.book 方法时，返回一个整数 K ，表示最大的 K 次预订。\n\n请按照以下步骤调用 MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)\n\n示例 1:\n\nMyCalendarThree(); MyCalendarThree.book(10, 20); // returns 1 MyCalendarThree.book(50, 60); // returns 1 MyCalendarThree.book(10, 40); // returns 2 MyCalendarThree.book(5, 15); // returns 3 MyCalendarThree.book(5, 10); // returns 3 MyCalendarThree.book(25, 55); // returns 3 解释: 前两个日程安排可以预订并且不相交，所以最大的 K 次预订是 1。 第三个日程安排\\[10,40\\]与第一个日程安排相交，最高的 K 次预订为 2。 其余的日程安排的最高 K 次预订仅为 3。 请注意，最后一次日程安排可能会导致局部最高 K 次预订为 2，但答案仍然是 3，原因是从开始到最后，时间\\[10,20\\]，\\[10,40\\]和\\[5,15\\]仍然会导致 3 次预订。 说明:\n\n每个测试用例，调用 MyCalendar.book 函数最多不超过 400 次。 调用函数 MyCalendar.book(start, end)时， start 和 end 的取值范围为 \\[0, 10^9\\]。\n\n## 二叉查找树法\n\n### 思路\n\n我们仍然可以使用上述的平衡二叉树的做法。只不过我们需要额外维护一个全局的最大值“k”，表示需要多少个预定。最终我们返回 k。 同时每一个 node 我们都增加一个属性 k，用来表示局部的最大值，对于每次插入，我们将 node 的 k 和全部的 k 进行比较，取出最大值即可。\n\n### 代码\n\n代码支持 Python3:\n\nPython3 Code:\n\n```\n<pre class=\"calibre18\">```\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Node</span><span class=\"hljs-params\">(object)</span>:</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span><span class=\"hljs-params\">(self, start, end, ktime=<span class=\"hljs-params\">1</span>)</span>:</span>\n        self.k = ktime\n        self.s = start\n        self.e = end\n        self.right = <span class=\"hljs-keyword\">None</span>\n        self.left = <span class=\"hljs-keyword\">None</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyCalendarThree</span><span class=\"hljs-params\">(object)</span>:</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span><span class=\"hljs-params\">(self)</span>:</span>\n        self.root = <span class=\"hljs-keyword\">None</span>\n        self.k = <span class=\"hljs-params\">0</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">book</span><span class=\"hljs-params\">(self, start, end)</span>:</span>\n        self.root = self.insert(self.root, start, end, <span class=\"hljs-params\">1</span>)\n        <span class=\"hljs-keyword\">return</span> self.k\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(self, root, start, end, k)</span>:</span>\n        <span class=\"hljs-keyword\">if</span> start >= end:\n            <span class=\"hljs-keyword\">return</span> root\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> root:\n            self.k = max(self.k, k)\n            <span class=\"hljs-keyword\">return</span> Node(start, end, k)\n        <span class=\"hljs-keyword\">else</span>:\n            <span class=\"hljs-keyword\">if</span> start >= root.e:\n                root.right = self.insert(root.right, start, end, k)\n                <span class=\"hljs-keyword\">return</span> root\n            <span class=\"hljs-keyword\">elif</span> end <= root.s:\n                root.left = self.insert(root.left, start, end, k)\n                <span class=\"hljs-keyword\">return</span> root\n            <span class=\"hljs-keyword\">else</span>:\n\n                a = min(root.s, start)\n                b = max(root.s, start)\n                c = min(root.e, end)\n                d = max(root.e, end)\n\n                root.left = self.insert(root.left, a, b, a == root.s <span class=\"hljs-keyword\">and</span> root.k <span class=\"hljs-keyword\">or</span> k)\n                root.right = self.insert(root.right, c,d, d == root.e <span class=\"hljs-keyword\">and</span> root.k <span class=\"hljs-keyword\">or</span> k)\n                root.k += k\n                root.s = b\n                root.e = c\n                self.k = max(root.k, self.k)\n                <span class=\"hljs-keyword\">return</span> root\n\n```\n```\n\n## Count Map 法\n\n### 思路\n\n这个是我在看了 Discussion [\\[C++\\] Map Solution, beats 95%+](https://leetcode.com/problems/my-calendar-iii/discuss/176950/C%2B%2B-Map-Solution-beats-95%2B) 之后写的解法，解法非常巧妙。\n\n我们使用一个 count map 来存储所有的预定，对于每次插入，我们执行`count[start] += 1`和`count[end] -= 1`。 count\\[t\\] 表示从 t 开始到下一个 t 我们有几个预定。因此我们需要对 count 进行排序才行。 我们维护一个最大值来 cnt 来表示需要的预定数。\n\n比如预定\\[1,3\\]和\\[5,7\\]，我们产生一个预定即可：\n\n![](images/019445b4b2ed30c77607b29d89ee1099332b8ff9.jpg)\n\n再比如预定\\[1,5\\]和\\[3,7\\]，我们需要两个预定：\n\n![](images/60660c079d8d02b6cc078d7c819dea2e95006f62.jpg)\n\n我们可以使用红黑树来简化时间复杂度，如果你使用的是 Java，可以直接使用现成的数据结构 TreeMap。我这里偷懒，每次都排序，时间复杂度会很高，但是可以 AC。\n\n读到这里，你可能会发现： 这个解法似乎更具有通用型。对于第一题我们可以判断 cnt 是否小于等于 1，对于第二题我们可以判断 cnt 是否小于等于 2。\n\n> 如果你不借助红黑树等数据结构直接使用 count-map 法，即每次都进行一次排序，第一题和第二题可能会直接超时。\n\n### 代码\n\n代码支持 Python3:\n\nPython3 Code:\n\n```\n<pre class=\"calibre18\">```\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyCalendarThree</span>:</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span><span class=\"hljs-params\">(self)</span>:</span>\n        self.count = dict()\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">book</span><span class=\"hljs-params\">(self, start: int, end: int)</span> -> int:</span>\n        self.count[start] = self.count.get(start, <span class=\"hljs-params\">0</span>) + <span class=\"hljs-params\">1</span>\n        self.count[end] = self.count.get(end, <span class=\"hljs-params\">0</span>) - <span class=\"hljs-params\">1</span>\n        cnt = <span class=\"hljs-params\">0</span>\n        cur = <span class=\"hljs-params\">0</span>\n\n        <span class=\"hljs-keyword\">for</span> k <span class=\"hljs-keyword\">in</span> sorted(self.count):\n            cur += self.count[k]\n            cnt = max(cnt, cur)\n        <span class=\"hljs-keyword\">return</span> cnt\n\n        <span class=\"hljs-title\"># Your MyCalendarThree object will be instantiated and called as such:</span>\n        <span class=\"hljs-title\"># obj = MyCalendarThree()</span>\n        <span class=\"hljs-title\"># param_1 = obj.book(start,end)</span>\n\n```\n```\n\n# 相关题目\n\nLeetCode 上有一个类似的系列《会议室》，截止目前（2020-02-03）有两道题目。其中一个简单一个中等，解题思路非常类似，大家用这个解题思路尝试一下，检测一下自己是否已经掌握。两道题分别是：\n\n- [252. 会议室](https://leetcode-cn.com/problems/meeting-rooms/)\n- [253. 会议室 II](https://leetcode-cn.com/problems/meeting-rooms-ii/)\n\n# 总结\n\n我们对 LeetCode 上的专题《我的日程安排》的三道题进行了汇总。对于区间判断是否重叠，我们可以反向判断，也可以正向判断。 暴力的方法是每次对所有的课程进行判断是否重叠，这种解法可以 AC。我们也可以进一步优化，使用二叉查找树来简化时间复杂度。最后我们介绍了一种 Count-Map 方法来通用解决所有的问题，不仅可以完美解决这三道题，还可以扩展到《会议室》系列的两道题。"},"options":{}}
</script>

<script src="https://jsdelivr.topthink.com/npm/lodash@4.17/lodash.min.js"></script>

<script src="https://jsdelivr.topthink.com/npm/react@17/umd/react.production.min.js"></script>

<script src="https://jsdelivr.topthink.com/npm/react-dom@17/umd/react-dom.production.min.js"></script>

<script src="asset/index.js"></script>

<script src="asset/plugins/theme-default/index.js"></script>

<script type="text/javascript">
    TopWrite.bootstrap();
</script>


</body></html>